// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: umbp_config.proto

#ifndef PROTOBUF_umbp_5fconfig_2eproto__INCLUDED
#define PROTOBUF_umbp_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace planning {
namespace umbp {
class BezierConfig;
class BezierConfigDefaultTypeInternal;
extern BezierConfigDefaultTypeInternal _BezierConfig_default_instance_;
class CarConfig;
class CarConfigDefaultTypeInternal;
extern CarConfigDefaultTypeInternal _CarConfig_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class CostConfig;
class CostConfigDefaultTypeInternal;
extern CostConfigDefaultTypeInternal _CostConfig_default_instance_;
class EfficiencyCost;
class EfficiencyCostDefaultTypeInternal;
extern EfficiencyCostDefaultTypeInternal _EfficiencyCost_default_instance_;
class EgoConfig;
class EgoConfigDefaultTypeInternal;
extern EgoConfigDefaultTypeInternal _EgoConfig_default_instance_;
class FpbConfig;
class FpbConfigDefaultTypeInternal;
extern FpbConfigDefaultTypeInternal _FpbConfig_default_instance_;
class MapConfig;
class MapConfigDefaultTypeInternal;
extern MapConfigDefaultTypeInternal _MapConfig_default_instance_;
class NavigationCost;
class NavigationCostDefaultTypeInternal;
extern NavigationCostDefaultTypeInternal _NavigationCost_default_instance_;
class PropogateConfig;
class PropogateConfigDefaultTypeInternal;
extern PropogateConfigDefaultTypeInternal _PropogateConfig_default_instance_;
class SafetyCost;
class SafetyCostDefaultTypeInternal;
extern SafetyCostDefaultTypeInternal _SafetyCost_default_instance_;
class SampleConfig;
class SampleConfigDefaultTypeInternal;
extern SampleConfigDefaultTypeInternal _SampleConfig_default_instance_;
class UserCost;
class UserCostDefaultTypeInternal;
extern UserCostDefaultTypeInternal _UserCost_default_instance_;
class WeightConfig;
class WeightConfigDefaultTypeInternal;
extern WeightConfigDefaultTypeInternal _WeightConfig_default_instance_;
}  // namespace umbp
}  // namespace planning

namespace planning {
namespace umbp {

namespace protobuf_umbp_5fconfig_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_umbp_5fconfig_2eproto

// ===================================================================

class EfficiencyCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.EfficiencyCost) */ {
 public:
  EfficiencyCost();
  virtual ~EfficiencyCost();

  EfficiencyCost(const EfficiencyCost& from);

  inline EfficiencyCost& operator=(const EfficiencyCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EfficiencyCost& default_instance();

  static inline const EfficiencyCost* internal_default_instance() {
    return reinterpret_cast<const EfficiencyCost*>(
               &_EfficiencyCost_default_instance_);
  }

  void Swap(EfficiencyCost* other);

  // implements Message ----------------------------------------------

  inline EfficiencyCost* New() const PROTOBUF_FINAL { return New(NULL); }

  EfficiencyCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EfficiencyCost& from);
  void MergeFrom(const EfficiencyCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EfficiencyCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ego_lack_speed_to_desired_unit_cost = 1;
  void clear_ego_lack_speed_to_desired_unit_cost();
  static const int kEgoLackSpeedToDesiredUnitCostFieldNumber = 1;
  double ego_lack_speed_to_desired_unit_cost() const;
  void set_ego_lack_speed_to_desired_unit_cost(double value);

  // double ego_over_speed_to_desired_unit_cost = 2;
  void clear_ego_over_speed_to_desired_unit_cost();
  static const int kEgoOverSpeedToDesiredUnitCostFieldNumber = 2;
  double ego_over_speed_to_desired_unit_cost() const;
  void set_ego_over_speed_to_desired_unit_cost(double value);

  // double ego_desired_speed_tolerate_gap = 3;
  void clear_ego_desired_speed_tolerate_gap();
  static const int kEgoDesiredSpeedTolerateGapFieldNumber = 3;
  double ego_desired_speed_tolerate_gap() const;
  void set_ego_desired_speed_tolerate_gap(double value);

  // double leading_distance_th = 4;
  void clear_leading_distance_th();
  static const int kLeadingDistanceThFieldNumber = 4;
  double leading_distance_th() const;
  void set_leading_distance_th(double value);

  // double min_distance_ratio = 5;
  void clear_min_distance_ratio();
  static const int kMinDistanceRatioFieldNumber = 5;
  double min_distance_ratio() const;
  void set_min_distance_ratio(double value);

  // double ego_speed_blocked_by_leading_unit_cost = 6;
  void clear_ego_speed_blocked_by_leading_unit_cost();
  static const int kEgoSpeedBlockedByLeadingUnitCostFieldNumber = 6;
  double ego_speed_blocked_by_leading_unit_cost() const;
  void set_ego_speed_blocked_by_leading_unit_cost(double value);

  // double leading_speed_blocked_desired_vel_unit_cost = 7;
  void clear_leading_speed_blocked_desired_vel_unit_cost();
  static const int kLeadingSpeedBlockedDesiredVelUnitCostFieldNumber = 7;
  double leading_speed_blocked_desired_vel_unit_cost() const;
  void set_leading_speed_blocked_desired_vel_unit_cost(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.EfficiencyCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ego_lack_speed_to_desired_unit_cost_;
  double ego_over_speed_to_desired_unit_cost_;
  double ego_desired_speed_tolerate_gap_;
  double leading_distance_th_;
  double min_distance_ratio_;
  double ego_speed_blocked_by_leading_unit_cost_;
  double leading_speed_blocked_desired_vel_unit_cost_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SafetyCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.SafetyCost) */ {
 public:
  SafetyCost();
  virtual ~SafetyCost();

  SafetyCost(const SafetyCost& from);

  inline SafetyCost& operator=(const SafetyCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyCost& default_instance();

  static inline const SafetyCost* internal_default_instance() {
    return reinterpret_cast<const SafetyCost*>(
               &_SafetyCost_default_instance_);
  }

  void Swap(SafetyCost* other);

  // implements Message ----------------------------------------------

  inline SafetyCost* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyCost& from);
  void MergeFrom(const SafetyCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ego_to_obs = 1;
  void clear_ego_to_obs();
  static const int kEgoToObsFieldNumber = 1;
  double ego_to_obs() const;
  void set_ego_to_obs(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.SafetyCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ego_to_obs_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.UserCost) */ {
 public:
  UserCost();
  virtual ~UserCost();

  UserCost(const UserCost& from);

  inline UserCost& operator=(const UserCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCost& default_instance();

  static inline const UserCost* internal_default_instance() {
    return reinterpret_cast<const UserCost*>(
               &_UserCost_default_instance_);
  }

  void Swap(UserCost* other);

  // implements Message ----------------------------------------------

  inline UserCost* New() const PROTOBUF_FINAL { return New(NULL); }

  UserCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserCost& from);
  void MergeFrom(const UserCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double late_operate_unit_cost = 1;
  void clear_late_operate_unit_cost();
  static const int kLateOperateUnitCostFieldNumber = 1;
  double late_operate_unit_cost() const;
  void set_late_operate_unit_cost(double value);

  // double cancel_operation_unit_cost = 2;
  void clear_cancel_operation_unit_cost();
  static const int kCancelOperationUnitCostFieldNumber = 2;
  double cancel_operation_unit_cost() const;
  void set_cancel_operation_unit_cost(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.UserCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double late_operate_unit_cost_;
  double cancel_operation_unit_cost_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavigationCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.NavigationCost) */ {
 public:
  NavigationCost();
  virtual ~NavigationCost();

  NavigationCost(const NavigationCost& from);

  inline NavigationCost& operator=(const NavigationCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationCost& default_instance();

  static inline const NavigationCost* internal_default_instance() {
    return reinterpret_cast<const NavigationCost*>(
               &_NavigationCost_default_instance_);
  }

  void Swap(NavigationCost* other);

  // implements Message ----------------------------------------------

  inline NavigationCost* New() const PROTOBUF_FINAL { return New(NULL); }

  NavigationCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavigationCost& from);
  void MergeFrom(const NavigationCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavigationCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ref_line_change = 1;
  void clear_ref_line_change();
  static const int kRefLineChangeFieldNumber = 1;
  double ref_line_change() const;
  void set_ref_line_change(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.NavigationCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ref_line_change_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FpbConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.FpbConfig) */ {
 public:
  FpbConfig();
  virtual ~FpbConfig();

  FpbConfig(const FpbConfig& from);

  inline FpbConfig& operator=(const FpbConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FpbConfig& default_instance();

  static inline const FpbConfig* internal_default_instance() {
    return reinterpret_cast<const FpbConfig*>(
               &_FpbConfig_default_instance_);
  }

  void Swap(FpbConfig* other);

  // implements Message ----------------------------------------------

  inline FpbConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  FpbConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FpbConfig& from);
  void MergeFrom(const FpbConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FpbConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double layer_time = 1;
  void clear_layer_time();
  static const int kLayerTimeFieldNumber = 1;
  double layer_time() const;
  void set_layer_time(double value);

  // double step = 2;
  void clear_step();
  static const int kStepFieldNumber = 2;
  double step() const;
  void set_step(double value);

  // double l_ref_to_left_road_bound = 4;
  void clear_l_ref_to_left_road_bound();
  static const int kLRefToLeftRoadBoundFieldNumber = 4;
  double l_ref_to_left_road_bound() const;
  void set_l_ref_to_left_road_bound(double value);

  // double l_ref_to_right_road_bound = 5;
  void clear_l_ref_to_right_road_bound();
  static const int kLRefToRightRoadBoundFieldNumber = 5;
  double l_ref_to_right_road_bound() const;
  void set_l_ref_to_right_road_bound(double value);

  // int32 tree_height = 3;
  void clear_tree_height();
  static const int kTreeHeightFieldNumber = 3;
  ::google::protobuf::int32 tree_height() const;
  void set_tree_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning.umbp.FpbConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double layer_time_;
  double step_;
  double l_ref_to_left_road_bound_;
  double l_ref_to_right_road_bound_;
  ::google::protobuf::int32 tree_height_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SampleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.SampleConfig) */ {
 public:
  SampleConfig();
  virtual ~SampleConfig();

  SampleConfig(const SampleConfig& from);

  inline SampleConfig& operator=(const SampleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SampleConfig& default_instance();

  static inline const SampleConfig* internal_default_instance() {
    return reinterpret_cast<const SampleConfig*>(
               &_SampleConfig_default_instance_);
  }

  void Swap(SampleConfig* other);

  // implements Message ----------------------------------------------

  inline SampleConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  SampleConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SampleConfig& from);
  void MergeFrom(const SampleConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SampleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double s_sample_distance = 1;
  void clear_s_sample_distance();
  static const int kSSampleDistanceFieldNumber = 1;
  double s_sample_distance() const;
  void set_s_sample_distance(double value);

  // double l_sample_distance = 3;
  void clear_l_sample_distance();
  static const int kLSampleDistanceFieldNumber = 3;
  double l_sample_distance() const;
  void set_l_sample_distance(double value);

  // int32 s_sample_num = 2;
  void clear_s_sample_num();
  static const int kSSampleNumFieldNumber = 2;
  ::google::protobuf::int32 s_sample_num() const;
  void set_s_sample_num(::google::protobuf::int32 value);

  // int32 l_sample_num = 4;
  void clear_l_sample_num();
  static const int kLSampleNumFieldNumber = 4;
  ::google::protobuf::int32 l_sample_num() const;
  void set_l_sample_num(::google::protobuf::int32 value);

  // double acc_ref = 5;
  void clear_acc_ref();
  static const int kAccRefFieldNumber = 5;
  double acc_ref() const;
  void set_acc_ref(double value);

  // double dec_ref = 6;
  void clear_dec_ref();
  static const int kDecRefFieldNumber = 6;
  double dec_ref() const;
  void set_dec_ref(double value);

  // double lane_width = 7;
  void clear_lane_width();
  static const int kLaneWidthFieldNumber = 7;
  double lane_width() const;
  void set_lane_width(double value);

  // double increased_sl_distance = 8;
  void clear_increased_sl_distance();
  static const int kIncreasedSlDistanceFieldNumber = 8;
  double increased_sl_distance() const;
  void set_increased_sl_distance(double value);

  // double increased_st_distance = 9;
  void clear_increased_st_distance();
  static const int kIncreasedStDistanceFieldNumber = 9;
  double increased_st_distance() const;
  void set_increased_st_distance(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.SampleConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double s_sample_distance_;
  double l_sample_distance_;
  ::google::protobuf::int32 s_sample_num_;
  ::google::protobuf::int32 l_sample_num_;
  double acc_ref_;
  double dec_ref_;
  double lane_width_;
  double increased_sl_distance_;
  double increased_st_distance_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropogateConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.PropogateConfig) */ {
 public:
  PropogateConfig();
  virtual ~PropogateConfig();

  PropogateConfig(const PropogateConfig& from);

  inline PropogateConfig& operator=(const PropogateConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropogateConfig& default_instance();

  static inline const PropogateConfig* internal_default_instance() {
    return reinterpret_cast<const PropogateConfig*>(
               &_PropogateConfig_default_instance_);
  }

  void Swap(PropogateConfig* other);

  // implements Message ----------------------------------------------

  inline PropogateConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PropogateConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PropogateConfig& from);
  void MergeFrom(const PropogateConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PropogateConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.FpbConfig fpb = 1;
  bool has_fpb() const;
  void clear_fpb();
  static const int kFpbFieldNumber = 1;
  const ::planning::umbp::FpbConfig& fpb() const;
  ::planning::umbp::FpbConfig* mutable_fpb();
  ::planning::umbp::FpbConfig* release_fpb();
  void set_allocated_fpb(::planning::umbp::FpbConfig* fpb);

  // .planning.umbp.SampleConfig sample = 2;
  bool has_sample() const;
  void clear_sample();
  static const int kSampleFieldNumber = 2;
  const ::planning::umbp::SampleConfig& sample() const;
  ::planning::umbp::SampleConfig* mutable_sample();
  ::planning::umbp::SampleConfig* release_sample();
  void set_allocated_sample(::planning::umbp::SampleConfig* sample);

  // @@protoc_insertion_point(class_scope:planning.umbp.PropogateConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::FpbConfig* fpb_;
  ::planning::umbp::SampleConfig* sample_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CostConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.CostConfig) */ {
 public:
  CostConfig();
  virtual ~CostConfig();

  CostConfig(const CostConfig& from);

  inline CostConfig& operator=(const CostConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CostConfig& default_instance();

  static inline const CostConfig* internal_default_instance() {
    return reinterpret_cast<const CostConfig*>(
               &_CostConfig_default_instance_);
  }

  void Swap(CostConfig* other);

  // implements Message ----------------------------------------------

  inline CostConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  CostConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CostConfig& from);
  void MergeFrom(const CostConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CostConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.EfficiencyCost efficiency = 1;
  bool has_efficiency() const;
  void clear_efficiency();
  static const int kEfficiencyFieldNumber = 1;
  const ::planning::umbp::EfficiencyCost& efficiency() const;
  ::planning::umbp::EfficiencyCost* mutable_efficiency();
  ::planning::umbp::EfficiencyCost* release_efficiency();
  void set_allocated_efficiency(::planning::umbp::EfficiencyCost* efficiency);

  // .planning.umbp.SafetyCost safety = 2;
  bool has_safety() const;
  void clear_safety();
  static const int kSafetyFieldNumber = 2;
  const ::planning::umbp::SafetyCost& safety() const;
  ::planning::umbp::SafetyCost* mutable_safety();
  ::planning::umbp::SafetyCost* release_safety();
  void set_allocated_safety(::planning::umbp::SafetyCost* safety);

  // .planning.umbp.UserCost user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  const ::planning::umbp::UserCost& user() const;
  ::planning::umbp::UserCost* mutable_user();
  ::planning::umbp::UserCost* release_user();
  void set_allocated_user(::planning::umbp::UserCost* user);

  // .planning.umbp.NavigationCost navigation = 4;
  bool has_navigation() const;
  void clear_navigation();
  static const int kNavigationFieldNumber = 4;
  const ::planning::umbp::NavigationCost& navigation() const;
  ::planning::umbp::NavigationCost* mutable_navigation();
  ::planning::umbp::NavigationCost* release_navigation();
  void set_allocated_navigation(::planning::umbp::NavigationCost* navigation);

  // double discount_factor = 5;
  void clear_discount_factor();
  static const int kDiscountFactorFieldNumber = 5;
  double discount_factor() const;
  void set_discount_factor(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.CostConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::EfficiencyCost* efficiency_;
  ::planning::umbp::SafetyCost* safety_;
  ::planning::umbp::UserCost* user_;
  ::planning::umbp::NavigationCost* navigation_;
  double discount_factor_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.EgoConfig) */ {
 public:
  EgoConfig();
  virtual ~EgoConfig();

  EgoConfig(const EgoConfig& from);

  inline EgoConfig& operator=(const EgoConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgoConfig& default_instance();

  static inline const EgoConfig* internal_default_instance() {
    return reinterpret_cast<const EgoConfig*>(
               &_EgoConfig_default_instance_);
  }

  void Swap(EgoConfig* other);

  // implements Message ----------------------------------------------

  inline EgoConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  EgoConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgoConfig& from);
  void MergeFrom(const EgoConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.CarConfig car = 1;
  bool has_car() const;
  void clear_car();
  static const int kCarFieldNumber = 1;
  const ::planning::umbp::CarConfig& car() const;
  ::planning::umbp::CarConfig* mutable_car();
  ::planning::umbp::CarConfig* release_car();
  void set_allocated_car(::planning::umbp::CarConfig* car);

  // .planning.umbp.MapConfig map = 2;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 2;
  const ::planning::umbp::MapConfig& map() const;
  ::planning::umbp::MapConfig* mutable_map();
  ::planning::umbp::MapConfig* release_map();
  void set_allocated_map(::planning::umbp::MapConfig* map);

  // @@protoc_insertion_point(class_scope:planning.umbp.EgoConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::CarConfig* car_;
  ::planning::umbp::MapConfig* map_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BezierConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.BezierConfig) */ {
 public:
  BezierConfig();
  virtual ~BezierConfig();

  BezierConfig(const BezierConfig& from);

  inline BezierConfig& operator=(const BezierConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BezierConfig& default_instance();

  static inline const BezierConfig* internal_default_instance() {
    return reinterpret_cast<const BezierConfig*>(
               &_BezierConfig_default_instance_);
  }

  void Swap(BezierConfig* other);

  // implements Message ----------------------------------------------

  inline BezierConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  BezierConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BezierConfig& from);
  void MergeFrom(const BezierConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BezierConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.WeightConfig weight = 1;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 1;
  const ::planning::umbp::WeightConfig& weight() const;
  ::planning::umbp::WeightConfig* mutable_weight();
  ::planning::umbp::WeightConfig* release_weight();
  void set_allocated_weight(::planning::umbp::WeightConfig* weight);

  // @@protoc_insertion_point(class_scope:planning.umbp.BezierConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::WeightConfig* weight_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeightConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.WeightConfig) */ {
 public:
  WeightConfig();
  virtual ~WeightConfig();

  WeightConfig(const WeightConfig& from);

  inline WeightConfig& operator=(const WeightConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightConfig& default_instance();

  static inline const WeightConfig* internal_default_instance() {
    return reinterpret_cast<const WeightConfig*>(
               &_WeightConfig_default_instance_);
  }

  void Swap(WeightConfig* other);

  // implements Message ----------------------------------------------

  inline WeightConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  WeightConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WeightConfig& from);
  void MergeFrom(const WeightConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WeightConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double weight_P = 1;
  void clear_weight_p();
  static const int kWeightPFieldNumber = 1;
  double weight_p() const;
  void set_weight_p(double value);

  // double weight_c = 2;
  void clear_weight_c();
  static const int kWeightCFieldNumber = 2;
  double weight_c() const;
  void set_weight_c(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.WeightConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double weight_p_;
  double weight_c_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CarConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.CarConfig) */ {
 public:
  CarConfig();
  virtual ~CarConfig();

  CarConfig(const CarConfig& from);

  inline CarConfig& operator=(const CarConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CarConfig& default_instance();

  static inline const CarConfig* internal_default_instance() {
    return reinterpret_cast<const CarConfig*>(
               &_CarConfig_default_instance_);
  }

  void Swap(CarConfig* other);

  // implements Message ----------------------------------------------

  inline CarConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  CarConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CarConfig& from);
  void MergeFrom(const CarConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CarConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double car_width = 1;
  void clear_car_width();
  static const int kCarWidthFieldNumber = 1;
  double car_width() const;
  void set_car_width(double value);

  // double car_length = 2;
  void clear_car_length();
  static const int kCarLengthFieldNumber = 2;
  double car_length() const;
  void set_car_length(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.CarConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double car_width_;
  double car_length_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.MapConfig) */ {
 public:
  MapConfig();
  virtual ~MapConfig();

  MapConfig(const MapConfig& from);

  inline MapConfig& operator=(const MapConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapConfig& default_instance();

  static inline const MapConfig* internal_default_instance() {
    return reinterpret_cast<const MapConfig*>(
               &_MapConfig_default_instance_);
  }

  void Swap(MapConfig* other);

  // implements Message ----------------------------------------------

  inline MapConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  MapConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapConfig& from);
  void MergeFrom(const MapConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double reference_speed = 1;
  void clear_reference_speed();
  static const int kReferenceSpeedFieldNumber = 1;
  double reference_speed() const;
  void set_reference_speed(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.MapConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double reference_speed_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  inline Config* New() const PROTOBUF_FINAL { return New(NULL); }

  Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // .planning.umbp.CostConfig cost = 4;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  const ::planning::umbp::CostConfig& cost() const;
  ::planning::umbp::CostConfig* mutable_cost();
  ::planning::umbp::CostConfig* release_cost();
  void set_allocated_cost(::planning::umbp::CostConfig* cost);

  // .planning.umbp.PropogateConfig propogate = 5;
  bool has_propogate() const;
  void clear_propogate();
  static const int kPropogateFieldNumber = 5;
  const ::planning::umbp::PropogateConfig& propogate() const;
  ::planning::umbp::PropogateConfig* mutable_propogate();
  ::planning::umbp::PropogateConfig* release_propogate();
  void set_allocated_propogate(::planning::umbp::PropogateConfig* propogate);

  // .planning.umbp.EgoConfig ego = 6;
  bool has_ego() const;
  void clear_ego();
  static const int kEgoFieldNumber = 6;
  const ::planning::umbp::EgoConfig& ego() const;
  ::planning::umbp::EgoConfig* mutable_ego();
  ::planning::umbp::EgoConfig* release_ego();
  void set_allocated_ego(::planning::umbp::EgoConfig* ego);

  // .planning.umbp.BezierConfig bezier = 7;
  bool has_bezier() const;
  void clear_bezier();
  static const int kBezierFieldNumber = 7;
  const ::planning::umbp::BezierConfig& bezier() const;
  ::planning::umbp::BezierConfig* mutable_bezier();
  ::planning::umbp::BezierConfig* release_bezier();
  void set_allocated_bezier(::planning::umbp::BezierConfig* bezier);

  // @@protoc_insertion_point(class_scope:planning.umbp.Config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::planning::umbp::CostConfig* cost_;
  ::planning::umbp::PropogateConfig* propogate_;
  ::planning::umbp::EgoConfig* ego_;
  ::planning::umbp::BezierConfig* bezier_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EfficiencyCost

// double ego_lack_speed_to_desired_unit_cost = 1;
inline void EfficiencyCost::clear_ego_lack_speed_to_desired_unit_cost() {
  ego_lack_speed_to_desired_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_lack_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_lack_speed_to_desired_unit_cost)
  return ego_lack_speed_to_desired_unit_cost_;
}
inline void EfficiencyCost::set_ego_lack_speed_to_desired_unit_cost(double value) {
  
  ego_lack_speed_to_desired_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_lack_speed_to_desired_unit_cost)
}

// double ego_over_speed_to_desired_unit_cost = 2;
inline void EfficiencyCost::clear_ego_over_speed_to_desired_unit_cost() {
  ego_over_speed_to_desired_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_over_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_over_speed_to_desired_unit_cost)
  return ego_over_speed_to_desired_unit_cost_;
}
inline void EfficiencyCost::set_ego_over_speed_to_desired_unit_cost(double value) {
  
  ego_over_speed_to_desired_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_over_speed_to_desired_unit_cost)
}

// double ego_desired_speed_tolerate_gap = 3;
inline void EfficiencyCost::clear_ego_desired_speed_tolerate_gap() {
  ego_desired_speed_tolerate_gap_ = 0;
}
inline double EfficiencyCost::ego_desired_speed_tolerate_gap() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_desired_speed_tolerate_gap)
  return ego_desired_speed_tolerate_gap_;
}
inline void EfficiencyCost::set_ego_desired_speed_tolerate_gap(double value) {
  
  ego_desired_speed_tolerate_gap_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_desired_speed_tolerate_gap)
}

// double leading_distance_th = 4;
inline void EfficiencyCost::clear_leading_distance_th() {
  leading_distance_th_ = 0;
}
inline double EfficiencyCost::leading_distance_th() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.leading_distance_th)
  return leading_distance_th_;
}
inline void EfficiencyCost::set_leading_distance_th(double value) {
  
  leading_distance_th_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.leading_distance_th)
}

// double min_distance_ratio = 5;
inline void EfficiencyCost::clear_min_distance_ratio() {
  min_distance_ratio_ = 0;
}
inline double EfficiencyCost::min_distance_ratio() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.min_distance_ratio)
  return min_distance_ratio_;
}
inline void EfficiencyCost::set_min_distance_ratio(double value) {
  
  min_distance_ratio_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.min_distance_ratio)
}

// double ego_speed_blocked_by_leading_unit_cost = 6;
inline void EfficiencyCost::clear_ego_speed_blocked_by_leading_unit_cost() {
  ego_speed_blocked_by_leading_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_speed_blocked_by_leading_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_speed_blocked_by_leading_unit_cost)
  return ego_speed_blocked_by_leading_unit_cost_;
}
inline void EfficiencyCost::set_ego_speed_blocked_by_leading_unit_cost(double value) {
  
  ego_speed_blocked_by_leading_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_speed_blocked_by_leading_unit_cost)
}

// double leading_speed_blocked_desired_vel_unit_cost = 7;
inline void EfficiencyCost::clear_leading_speed_blocked_desired_vel_unit_cost() {
  leading_speed_blocked_desired_vel_unit_cost_ = 0;
}
inline double EfficiencyCost::leading_speed_blocked_desired_vel_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.leading_speed_blocked_desired_vel_unit_cost)
  return leading_speed_blocked_desired_vel_unit_cost_;
}
inline void EfficiencyCost::set_leading_speed_blocked_desired_vel_unit_cost(double value) {
  
  leading_speed_blocked_desired_vel_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.leading_speed_blocked_desired_vel_unit_cost)
}

// -------------------------------------------------------------------

// SafetyCost

// double ego_to_obs = 1;
inline void SafetyCost::clear_ego_to_obs() {
  ego_to_obs_ = 0;
}
inline double SafetyCost::ego_to_obs() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SafetyCost.ego_to_obs)
  return ego_to_obs_;
}
inline void SafetyCost::set_ego_to_obs(double value) {
  
  ego_to_obs_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SafetyCost.ego_to_obs)
}

// -------------------------------------------------------------------

// UserCost

// double late_operate_unit_cost = 1;
inline void UserCost::clear_late_operate_unit_cost() {
  late_operate_unit_cost_ = 0;
}
inline double UserCost::late_operate_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.UserCost.late_operate_unit_cost)
  return late_operate_unit_cost_;
}
inline void UserCost::set_late_operate_unit_cost(double value) {
  
  late_operate_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.UserCost.late_operate_unit_cost)
}

// double cancel_operation_unit_cost = 2;
inline void UserCost::clear_cancel_operation_unit_cost() {
  cancel_operation_unit_cost_ = 0;
}
inline double UserCost::cancel_operation_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.UserCost.cancel_operation_unit_cost)
  return cancel_operation_unit_cost_;
}
inline void UserCost::set_cancel_operation_unit_cost(double value) {
  
  cancel_operation_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.UserCost.cancel_operation_unit_cost)
}

// -------------------------------------------------------------------

// NavigationCost

// double ref_line_change = 1;
inline void NavigationCost::clear_ref_line_change() {
  ref_line_change_ = 0;
}
inline double NavigationCost::ref_line_change() const {
  // @@protoc_insertion_point(field_get:planning.umbp.NavigationCost.ref_line_change)
  return ref_line_change_;
}
inline void NavigationCost::set_ref_line_change(double value) {
  
  ref_line_change_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.NavigationCost.ref_line_change)
}

// -------------------------------------------------------------------

// FpbConfig

// double layer_time = 1;
inline void FpbConfig::clear_layer_time() {
  layer_time_ = 0;
}
inline double FpbConfig::layer_time() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.layer_time)
  return layer_time_;
}
inline void FpbConfig::set_layer_time(double value) {
  
  layer_time_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.layer_time)
}

// double step = 2;
inline void FpbConfig::clear_step() {
  step_ = 0;
}
inline double FpbConfig::step() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.step)
  return step_;
}
inline void FpbConfig::set_step(double value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.step)
}

// int32 tree_height = 3;
inline void FpbConfig::clear_tree_height() {
  tree_height_ = 0;
}
inline ::google::protobuf::int32 FpbConfig::tree_height() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.tree_height)
  return tree_height_;
}
inline void FpbConfig::set_tree_height(::google::protobuf::int32 value) {
  
  tree_height_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.tree_height)
}

// double l_ref_to_left_road_bound = 4;
inline void FpbConfig::clear_l_ref_to_left_road_bound() {
  l_ref_to_left_road_bound_ = 0;
}
inline double FpbConfig::l_ref_to_left_road_bound() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.l_ref_to_left_road_bound)
  return l_ref_to_left_road_bound_;
}
inline void FpbConfig::set_l_ref_to_left_road_bound(double value) {
  
  l_ref_to_left_road_bound_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.l_ref_to_left_road_bound)
}

// double l_ref_to_right_road_bound = 5;
inline void FpbConfig::clear_l_ref_to_right_road_bound() {
  l_ref_to_right_road_bound_ = 0;
}
inline double FpbConfig::l_ref_to_right_road_bound() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.l_ref_to_right_road_bound)
  return l_ref_to_right_road_bound_;
}
inline void FpbConfig::set_l_ref_to_right_road_bound(double value) {
  
  l_ref_to_right_road_bound_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.l_ref_to_right_road_bound)
}

// -------------------------------------------------------------------

// SampleConfig

// double s_sample_distance = 1;
inline void SampleConfig::clear_s_sample_distance() {
  s_sample_distance_ = 0;
}
inline double SampleConfig::s_sample_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.s_sample_distance)
  return s_sample_distance_;
}
inline void SampleConfig::set_s_sample_distance(double value) {
  
  s_sample_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.s_sample_distance)
}

// int32 s_sample_num = 2;
inline void SampleConfig::clear_s_sample_num() {
  s_sample_num_ = 0;
}
inline ::google::protobuf::int32 SampleConfig::s_sample_num() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.s_sample_num)
  return s_sample_num_;
}
inline void SampleConfig::set_s_sample_num(::google::protobuf::int32 value) {
  
  s_sample_num_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.s_sample_num)
}

// double l_sample_distance = 3;
inline void SampleConfig::clear_l_sample_distance() {
  l_sample_distance_ = 0;
}
inline double SampleConfig::l_sample_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.l_sample_distance)
  return l_sample_distance_;
}
inline void SampleConfig::set_l_sample_distance(double value) {
  
  l_sample_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.l_sample_distance)
}

// int32 l_sample_num = 4;
inline void SampleConfig::clear_l_sample_num() {
  l_sample_num_ = 0;
}
inline ::google::protobuf::int32 SampleConfig::l_sample_num() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.l_sample_num)
  return l_sample_num_;
}
inline void SampleConfig::set_l_sample_num(::google::protobuf::int32 value) {
  
  l_sample_num_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.l_sample_num)
}

// double acc_ref = 5;
inline void SampleConfig::clear_acc_ref() {
  acc_ref_ = 0;
}
inline double SampleConfig::acc_ref() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.acc_ref)
  return acc_ref_;
}
inline void SampleConfig::set_acc_ref(double value) {
  
  acc_ref_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.acc_ref)
}

// double dec_ref = 6;
inline void SampleConfig::clear_dec_ref() {
  dec_ref_ = 0;
}
inline double SampleConfig::dec_ref() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.dec_ref)
  return dec_ref_;
}
inline void SampleConfig::set_dec_ref(double value) {
  
  dec_ref_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.dec_ref)
}

// double lane_width = 7;
inline void SampleConfig::clear_lane_width() {
  lane_width_ = 0;
}
inline double SampleConfig::lane_width() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.lane_width)
  return lane_width_;
}
inline void SampleConfig::set_lane_width(double value) {
  
  lane_width_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.lane_width)
}

// double increased_sl_distance = 8;
inline void SampleConfig::clear_increased_sl_distance() {
  increased_sl_distance_ = 0;
}
inline double SampleConfig::increased_sl_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.increased_sl_distance)
  return increased_sl_distance_;
}
inline void SampleConfig::set_increased_sl_distance(double value) {
  
  increased_sl_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.increased_sl_distance)
}

// double increased_st_distance = 9;
inline void SampleConfig::clear_increased_st_distance() {
  increased_st_distance_ = 0;
}
inline double SampleConfig::increased_st_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.increased_st_distance)
  return increased_st_distance_;
}
inline void SampleConfig::set_increased_st_distance(double value) {
  
  increased_st_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.increased_st_distance)
}

// -------------------------------------------------------------------

// PropogateConfig

// .planning.umbp.FpbConfig fpb = 1;
inline bool PropogateConfig::has_fpb() const {
  return this != internal_default_instance() && fpb_ != NULL;
}
inline void PropogateConfig::clear_fpb() {
  if (GetArenaNoVirtual() == NULL && fpb_ != NULL) delete fpb_;
  fpb_ = NULL;
}
inline const ::planning::umbp::FpbConfig& PropogateConfig::fpb() const {
  // @@protoc_insertion_point(field_get:planning.umbp.PropogateConfig.fpb)
  return fpb_ != NULL ? *fpb_
                         : *::planning::umbp::FpbConfig::internal_default_instance();
}
inline ::planning::umbp::FpbConfig* PropogateConfig::mutable_fpb() {
  
  if (fpb_ == NULL) {
    fpb_ = new ::planning::umbp::FpbConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.PropogateConfig.fpb)
  return fpb_;
}
inline ::planning::umbp::FpbConfig* PropogateConfig::release_fpb() {
  // @@protoc_insertion_point(field_release:planning.umbp.PropogateConfig.fpb)
  
  ::planning::umbp::FpbConfig* temp = fpb_;
  fpb_ = NULL;
  return temp;
}
inline void PropogateConfig::set_allocated_fpb(::planning::umbp::FpbConfig* fpb) {
  delete fpb_;
  fpb_ = fpb;
  if (fpb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.PropogateConfig.fpb)
}

// .planning.umbp.SampleConfig sample = 2;
inline bool PropogateConfig::has_sample() const {
  return this != internal_default_instance() && sample_ != NULL;
}
inline void PropogateConfig::clear_sample() {
  if (GetArenaNoVirtual() == NULL && sample_ != NULL) delete sample_;
  sample_ = NULL;
}
inline const ::planning::umbp::SampleConfig& PropogateConfig::sample() const {
  // @@protoc_insertion_point(field_get:planning.umbp.PropogateConfig.sample)
  return sample_ != NULL ? *sample_
                         : *::planning::umbp::SampleConfig::internal_default_instance();
}
inline ::planning::umbp::SampleConfig* PropogateConfig::mutable_sample() {
  
  if (sample_ == NULL) {
    sample_ = new ::planning::umbp::SampleConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.PropogateConfig.sample)
  return sample_;
}
inline ::planning::umbp::SampleConfig* PropogateConfig::release_sample() {
  // @@protoc_insertion_point(field_release:planning.umbp.PropogateConfig.sample)
  
  ::planning::umbp::SampleConfig* temp = sample_;
  sample_ = NULL;
  return temp;
}
inline void PropogateConfig::set_allocated_sample(::planning::umbp::SampleConfig* sample) {
  delete sample_;
  sample_ = sample;
  if (sample) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.PropogateConfig.sample)
}

// -------------------------------------------------------------------

// CostConfig

// .planning.umbp.EfficiencyCost efficiency = 1;
inline bool CostConfig::has_efficiency() const {
  return this != internal_default_instance() && efficiency_ != NULL;
}
inline void CostConfig::clear_efficiency() {
  if (GetArenaNoVirtual() == NULL && efficiency_ != NULL) delete efficiency_;
  efficiency_ = NULL;
}
inline const ::planning::umbp::EfficiencyCost& CostConfig::efficiency() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.efficiency)
  return efficiency_ != NULL ? *efficiency_
                         : *::planning::umbp::EfficiencyCost::internal_default_instance();
}
inline ::planning::umbp::EfficiencyCost* CostConfig::mutable_efficiency() {
  
  if (efficiency_ == NULL) {
    efficiency_ = new ::planning::umbp::EfficiencyCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.efficiency)
  return efficiency_;
}
inline ::planning::umbp::EfficiencyCost* CostConfig::release_efficiency() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.efficiency)
  
  ::planning::umbp::EfficiencyCost* temp = efficiency_;
  efficiency_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_efficiency(::planning::umbp::EfficiencyCost* efficiency) {
  delete efficiency_;
  efficiency_ = efficiency;
  if (efficiency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.efficiency)
}

// .planning.umbp.SafetyCost safety = 2;
inline bool CostConfig::has_safety() const {
  return this != internal_default_instance() && safety_ != NULL;
}
inline void CostConfig::clear_safety() {
  if (GetArenaNoVirtual() == NULL && safety_ != NULL) delete safety_;
  safety_ = NULL;
}
inline const ::planning::umbp::SafetyCost& CostConfig::safety() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.safety)
  return safety_ != NULL ? *safety_
                         : *::planning::umbp::SafetyCost::internal_default_instance();
}
inline ::planning::umbp::SafetyCost* CostConfig::mutable_safety() {
  
  if (safety_ == NULL) {
    safety_ = new ::planning::umbp::SafetyCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.safety)
  return safety_;
}
inline ::planning::umbp::SafetyCost* CostConfig::release_safety() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.safety)
  
  ::planning::umbp::SafetyCost* temp = safety_;
  safety_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_safety(::planning::umbp::SafetyCost* safety) {
  delete safety_;
  safety_ = safety;
  if (safety) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.safety)
}

// .planning.umbp.UserCost user = 3;
inline bool CostConfig::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void CostConfig::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
inline const ::planning::umbp::UserCost& CostConfig::user() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.user)
  return user_ != NULL ? *user_
                         : *::planning::umbp::UserCost::internal_default_instance();
}
inline ::planning::umbp::UserCost* CostConfig::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::planning::umbp::UserCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.user)
  return user_;
}
inline ::planning::umbp::UserCost* CostConfig::release_user() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.user)
  
  ::planning::umbp::UserCost* temp = user_;
  user_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_user(::planning::umbp::UserCost* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.user)
}

// .planning.umbp.NavigationCost navigation = 4;
inline bool CostConfig::has_navigation() const {
  return this != internal_default_instance() && navigation_ != NULL;
}
inline void CostConfig::clear_navigation() {
  if (GetArenaNoVirtual() == NULL && navigation_ != NULL) delete navigation_;
  navigation_ = NULL;
}
inline const ::planning::umbp::NavigationCost& CostConfig::navigation() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.navigation)
  return navigation_ != NULL ? *navigation_
                         : *::planning::umbp::NavigationCost::internal_default_instance();
}
inline ::planning::umbp::NavigationCost* CostConfig::mutable_navigation() {
  
  if (navigation_ == NULL) {
    navigation_ = new ::planning::umbp::NavigationCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.navigation)
  return navigation_;
}
inline ::planning::umbp::NavigationCost* CostConfig::release_navigation() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.navigation)
  
  ::planning::umbp::NavigationCost* temp = navigation_;
  navigation_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_navigation(::planning::umbp::NavigationCost* navigation) {
  delete navigation_;
  navigation_ = navigation;
  if (navigation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.navigation)
}

// double discount_factor = 5;
inline void CostConfig::clear_discount_factor() {
  discount_factor_ = 0;
}
inline double CostConfig::discount_factor() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.discount_factor)
  return discount_factor_;
}
inline void CostConfig::set_discount_factor(double value) {
  
  discount_factor_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CostConfig.discount_factor)
}

// -------------------------------------------------------------------

// EgoConfig

// .planning.umbp.CarConfig car = 1;
inline bool EgoConfig::has_car() const {
  return this != internal_default_instance() && car_ != NULL;
}
inline void EgoConfig::clear_car() {
  if (GetArenaNoVirtual() == NULL && car_ != NULL) delete car_;
  car_ = NULL;
}
inline const ::planning::umbp::CarConfig& EgoConfig::car() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EgoConfig.car)
  return car_ != NULL ? *car_
                         : *::planning::umbp::CarConfig::internal_default_instance();
}
inline ::planning::umbp::CarConfig* EgoConfig::mutable_car() {
  
  if (car_ == NULL) {
    car_ = new ::planning::umbp::CarConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.EgoConfig.car)
  return car_;
}
inline ::planning::umbp::CarConfig* EgoConfig::release_car() {
  // @@protoc_insertion_point(field_release:planning.umbp.EgoConfig.car)
  
  ::planning::umbp::CarConfig* temp = car_;
  car_ = NULL;
  return temp;
}
inline void EgoConfig::set_allocated_car(::planning::umbp::CarConfig* car) {
  delete car_;
  car_ = car;
  if (car) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.EgoConfig.car)
}

// .planning.umbp.MapConfig map = 2;
inline bool EgoConfig::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void EgoConfig::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
inline const ::planning::umbp::MapConfig& EgoConfig::map() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EgoConfig.map)
  return map_ != NULL ? *map_
                         : *::planning::umbp::MapConfig::internal_default_instance();
}
inline ::planning::umbp::MapConfig* EgoConfig::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::planning::umbp::MapConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.EgoConfig.map)
  return map_;
}
inline ::planning::umbp::MapConfig* EgoConfig::release_map() {
  // @@protoc_insertion_point(field_release:planning.umbp.EgoConfig.map)
  
  ::planning::umbp::MapConfig* temp = map_;
  map_ = NULL;
  return temp;
}
inline void EgoConfig::set_allocated_map(::planning::umbp::MapConfig* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.EgoConfig.map)
}

// -------------------------------------------------------------------

// BezierConfig

// .planning.umbp.WeightConfig weight = 1;
inline bool BezierConfig::has_weight() const {
  return this != internal_default_instance() && weight_ != NULL;
}
inline void BezierConfig::clear_weight() {
  if (GetArenaNoVirtual() == NULL && weight_ != NULL) delete weight_;
  weight_ = NULL;
}
inline const ::planning::umbp::WeightConfig& BezierConfig::weight() const {
  // @@protoc_insertion_point(field_get:planning.umbp.BezierConfig.weight)
  return weight_ != NULL ? *weight_
                         : *::planning::umbp::WeightConfig::internal_default_instance();
}
inline ::planning::umbp::WeightConfig* BezierConfig::mutable_weight() {
  
  if (weight_ == NULL) {
    weight_ = new ::planning::umbp::WeightConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.BezierConfig.weight)
  return weight_;
}
inline ::planning::umbp::WeightConfig* BezierConfig::release_weight() {
  // @@protoc_insertion_point(field_release:planning.umbp.BezierConfig.weight)
  
  ::planning::umbp::WeightConfig* temp = weight_;
  weight_ = NULL;
  return temp;
}
inline void BezierConfig::set_allocated_weight(::planning::umbp::WeightConfig* weight) {
  delete weight_;
  weight_ = weight;
  if (weight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.BezierConfig.weight)
}

// -------------------------------------------------------------------

// WeightConfig

// double weight_P = 1;
inline void WeightConfig::clear_weight_p() {
  weight_p_ = 0;
}
inline double WeightConfig::weight_p() const {
  // @@protoc_insertion_point(field_get:planning.umbp.WeightConfig.weight_P)
  return weight_p_;
}
inline void WeightConfig::set_weight_p(double value) {
  
  weight_p_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.WeightConfig.weight_P)
}

// double weight_c = 2;
inline void WeightConfig::clear_weight_c() {
  weight_c_ = 0;
}
inline double WeightConfig::weight_c() const {
  // @@protoc_insertion_point(field_get:planning.umbp.WeightConfig.weight_c)
  return weight_c_;
}
inline void WeightConfig::set_weight_c(double value) {
  
  weight_c_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.WeightConfig.weight_c)
}

// -------------------------------------------------------------------

// CarConfig

// double car_width = 1;
inline void CarConfig::clear_car_width() {
  car_width_ = 0;
}
inline double CarConfig::car_width() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CarConfig.car_width)
  return car_width_;
}
inline void CarConfig::set_car_width(double value) {
  
  car_width_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CarConfig.car_width)
}

// double car_length = 2;
inline void CarConfig::clear_car_length() {
  car_length_ = 0;
}
inline double CarConfig::car_length() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CarConfig.car_length)
  return car_length_;
}
inline void CarConfig::set_car_length(double value) {
  
  car_length_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CarConfig.car_length)
}

// -------------------------------------------------------------------

// MapConfig

// double reference_speed = 1;
inline void MapConfig::clear_reference_speed() {
  reference_speed_ = 0;
}
inline double MapConfig::reference_speed() const {
  // @@protoc_insertion_point(field_get:planning.umbp.MapConfig.reference_speed)
  return reference_speed_;
}
inline void MapConfig::set_reference_speed(double value) {
  
  reference_speed_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.MapConfig.reference_speed)
}

// -------------------------------------------------------------------

// Config

// string name = 1;
inline void Config::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::name() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.name)
  return name_.GetNoArena();
}
inline void Config::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.name)
}
#if LANG_CXX11
inline void Config::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.name)
}
#endif
inline void Config::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.name)
}
inline void Config::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.name)
}
inline ::std::string* Config::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_name() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.name)
}

// string version = 2;
inline void Config::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::version() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.version)
  return version_.GetNoArena();
}
inline void Config::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.version)
}
#if LANG_CXX11
inline void Config::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.version)
}
#endif
inline void Config::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.version)
}
inline void Config::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.version)
}
inline ::std::string* Config::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_version() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.version)
}

// string status = 3;
inline void Config::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::status() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.status)
  return status_.GetNoArena();
}
inline void Config::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.status)
}
#if LANG_CXX11
inline void Config::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.status)
}
#endif
inline void Config::set_status(const char* value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.status)
}
inline void Config::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.status)
}
inline ::std::string* Config::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_status() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.status)
}

// .planning.umbp.CostConfig cost = 4;
inline bool Config::has_cost() const {
  return this != internal_default_instance() && cost_ != NULL;
}
inline void Config::clear_cost() {
  if (GetArenaNoVirtual() == NULL && cost_ != NULL) delete cost_;
  cost_ = NULL;
}
inline const ::planning::umbp::CostConfig& Config::cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.cost)
  return cost_ != NULL ? *cost_
                         : *::planning::umbp::CostConfig::internal_default_instance();
}
inline ::planning::umbp::CostConfig* Config::mutable_cost() {
  
  if (cost_ == NULL) {
    cost_ = new ::planning::umbp::CostConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.cost)
  return cost_;
}
inline ::planning::umbp::CostConfig* Config::release_cost() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.cost)
  
  ::planning::umbp::CostConfig* temp = cost_;
  cost_ = NULL;
  return temp;
}
inline void Config::set_allocated_cost(::planning::umbp::CostConfig* cost) {
  delete cost_;
  cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.cost)
}

// .planning.umbp.PropogateConfig propogate = 5;
inline bool Config::has_propogate() const {
  return this != internal_default_instance() && propogate_ != NULL;
}
inline void Config::clear_propogate() {
  if (GetArenaNoVirtual() == NULL && propogate_ != NULL) delete propogate_;
  propogate_ = NULL;
}
inline const ::planning::umbp::PropogateConfig& Config::propogate() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.propogate)
  return propogate_ != NULL ? *propogate_
                         : *::planning::umbp::PropogateConfig::internal_default_instance();
}
inline ::planning::umbp::PropogateConfig* Config::mutable_propogate() {
  
  if (propogate_ == NULL) {
    propogate_ = new ::planning::umbp::PropogateConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.propogate)
  return propogate_;
}
inline ::planning::umbp::PropogateConfig* Config::release_propogate() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.propogate)
  
  ::planning::umbp::PropogateConfig* temp = propogate_;
  propogate_ = NULL;
  return temp;
}
inline void Config::set_allocated_propogate(::planning::umbp::PropogateConfig* propogate) {
  delete propogate_;
  propogate_ = propogate;
  if (propogate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.propogate)
}

// .planning.umbp.EgoConfig ego = 6;
inline bool Config::has_ego() const {
  return this != internal_default_instance() && ego_ != NULL;
}
inline void Config::clear_ego() {
  if (GetArenaNoVirtual() == NULL && ego_ != NULL) delete ego_;
  ego_ = NULL;
}
inline const ::planning::umbp::EgoConfig& Config::ego() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.ego)
  return ego_ != NULL ? *ego_
                         : *::planning::umbp::EgoConfig::internal_default_instance();
}
inline ::planning::umbp::EgoConfig* Config::mutable_ego() {
  
  if (ego_ == NULL) {
    ego_ = new ::planning::umbp::EgoConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.ego)
  return ego_;
}
inline ::planning::umbp::EgoConfig* Config::release_ego() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.ego)
  
  ::planning::umbp::EgoConfig* temp = ego_;
  ego_ = NULL;
  return temp;
}
inline void Config::set_allocated_ego(::planning::umbp::EgoConfig* ego) {
  delete ego_;
  ego_ = ego;
  if (ego) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.ego)
}

// .planning.umbp.BezierConfig bezier = 7;
inline bool Config::has_bezier() const {
  return this != internal_default_instance() && bezier_ != NULL;
}
inline void Config::clear_bezier() {
  if (GetArenaNoVirtual() == NULL && bezier_ != NULL) delete bezier_;
  bezier_ = NULL;
}
inline const ::planning::umbp::BezierConfig& Config::bezier() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.bezier)
  return bezier_ != NULL ? *bezier_
                         : *::planning::umbp::BezierConfig::internal_default_instance();
}
inline ::planning::umbp::BezierConfig* Config::mutable_bezier() {
  
  if (bezier_ == NULL) {
    bezier_ = new ::planning::umbp::BezierConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.bezier)
  return bezier_;
}
inline ::planning::umbp::BezierConfig* Config::release_bezier() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.bezier)
  
  ::planning::umbp::BezierConfig* temp = bezier_;
  bezier_ = NULL;
  return temp;
}
inline void Config::set_allocated_bezier(::planning::umbp::BezierConfig* bezier) {
  delete bezier_;
  bezier_ = bezier;
  if (bezier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.bezier)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace umbp
}  // namespace planning

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_umbp_5fconfig_2eproto__INCLUDED
