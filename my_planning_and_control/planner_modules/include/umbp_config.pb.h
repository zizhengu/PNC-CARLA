// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: umbp_config.proto

#ifndef PROTOBUF_INCLUDED_umbp_5fconfig_2eproto
#define PROTOBUF_INCLUDED_umbp_5fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_umbp_5fconfig_2eproto 

namespace protobuf_umbp_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_umbp_5fconfig_2eproto
namespace planning {
namespace umbp {
class BezierConfig;
class BezierConfigDefaultTypeInternal;
extern BezierConfigDefaultTypeInternal _BezierConfig_default_instance_;
class CarConfig;
class CarConfigDefaultTypeInternal;
extern CarConfigDefaultTypeInternal _CarConfig_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class CostConfig;
class CostConfigDefaultTypeInternal;
extern CostConfigDefaultTypeInternal _CostConfig_default_instance_;
class CubeConfig;
class CubeConfigDefaultTypeInternal;
extern CubeConfigDefaultTypeInternal _CubeConfig_default_instance_;
class EfficiencyCost;
class EfficiencyCostDefaultTypeInternal;
extern EfficiencyCostDefaultTypeInternal _EfficiencyCost_default_instance_;
class EgoConfig;
class EgoConfigDefaultTypeInternal;
extern EgoConfigDefaultTypeInternal _EgoConfig_default_instance_;
class FpbConfig;
class FpbConfigDefaultTypeInternal;
extern FpbConfigDefaultTypeInternal _FpbConfig_default_instance_;
class HdiCost;
class HdiCostDefaultTypeInternal;
extern HdiCostDefaultTypeInternal _HdiCost_default_instance_;
class MapConfig;
class MapConfigDefaultTypeInternal;
extern MapConfigDefaultTypeInternal _MapConfig_default_instance_;
class NavigationCost;
class NavigationCostDefaultTypeInternal;
extern NavigationCostDefaultTypeInternal _NavigationCost_default_instance_;
class PropogateConfig;
class PropogateConfigDefaultTypeInternal;
extern PropogateConfigDefaultTypeInternal _PropogateConfig_default_instance_;
class SafetyCost;
class SafetyCostDefaultTypeInternal;
extern SafetyCostDefaultTypeInternal _SafetyCost_default_instance_;
class SampleConfig;
class SampleConfigDefaultTypeInternal;
extern SampleConfigDefaultTypeInternal _SampleConfig_default_instance_;
class UserCost;
class UserCostDefaultTypeInternal;
extern UserCostDefaultTypeInternal _UserCost_default_instance_;
class WeightConfig;
class WeightConfigDefaultTypeInternal;
extern WeightConfigDefaultTypeInternal _WeightConfig_default_instance_;
}  // namespace umbp
}  // namespace planning
namespace google {
namespace protobuf {
template<> ::planning::umbp::BezierConfig* Arena::CreateMaybeMessage<::planning::umbp::BezierConfig>(Arena*);
template<> ::planning::umbp::CarConfig* Arena::CreateMaybeMessage<::planning::umbp::CarConfig>(Arena*);
template<> ::planning::umbp::Config* Arena::CreateMaybeMessage<::planning::umbp::Config>(Arena*);
template<> ::planning::umbp::CostConfig* Arena::CreateMaybeMessage<::planning::umbp::CostConfig>(Arena*);
template<> ::planning::umbp::CubeConfig* Arena::CreateMaybeMessage<::planning::umbp::CubeConfig>(Arena*);
template<> ::planning::umbp::EfficiencyCost* Arena::CreateMaybeMessage<::planning::umbp::EfficiencyCost>(Arena*);
template<> ::planning::umbp::EgoConfig* Arena::CreateMaybeMessage<::planning::umbp::EgoConfig>(Arena*);
template<> ::planning::umbp::FpbConfig* Arena::CreateMaybeMessage<::planning::umbp::FpbConfig>(Arena*);
template<> ::planning::umbp::HdiCost* Arena::CreateMaybeMessage<::planning::umbp::HdiCost>(Arena*);
template<> ::planning::umbp::MapConfig* Arena::CreateMaybeMessage<::planning::umbp::MapConfig>(Arena*);
template<> ::planning::umbp::NavigationCost* Arena::CreateMaybeMessage<::planning::umbp::NavigationCost>(Arena*);
template<> ::planning::umbp::PropogateConfig* Arena::CreateMaybeMessage<::planning::umbp::PropogateConfig>(Arena*);
template<> ::planning::umbp::SafetyCost* Arena::CreateMaybeMessage<::planning::umbp::SafetyCost>(Arena*);
template<> ::planning::umbp::SampleConfig* Arena::CreateMaybeMessage<::planning::umbp::SampleConfig>(Arena*);
template<> ::planning::umbp::UserCost* Arena::CreateMaybeMessage<::planning::umbp::UserCost>(Arena*);
template<> ::planning::umbp::WeightConfig* Arena::CreateMaybeMessage<::planning::umbp::WeightConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace planning {
namespace umbp {

// ===================================================================

class EfficiencyCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.EfficiencyCost) */ {
 public:
  EfficiencyCost();
  virtual ~EfficiencyCost();

  EfficiencyCost(const EfficiencyCost& from);

  inline EfficiencyCost& operator=(const EfficiencyCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EfficiencyCost(EfficiencyCost&& from) noexcept
    : EfficiencyCost() {
    *this = ::std::move(from);
  }

  inline EfficiencyCost& operator=(EfficiencyCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EfficiencyCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EfficiencyCost* internal_default_instance() {
    return reinterpret_cast<const EfficiencyCost*>(
               &_EfficiencyCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EfficiencyCost* other);
  friend void swap(EfficiencyCost& a, EfficiencyCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EfficiencyCost* New() const final {
    return CreateMaybeMessage<EfficiencyCost>(NULL);
  }

  EfficiencyCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EfficiencyCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EfficiencyCost& from);
  void MergeFrom(const EfficiencyCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EfficiencyCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ego_lack_speed_to_desired_unit_cost = 1;
  void clear_ego_lack_speed_to_desired_unit_cost();
  static const int kEgoLackSpeedToDesiredUnitCostFieldNumber = 1;
  double ego_lack_speed_to_desired_unit_cost() const;
  void set_ego_lack_speed_to_desired_unit_cost(double value);

  // double ego_over_speed_to_desired_unit_cost = 2;
  void clear_ego_over_speed_to_desired_unit_cost();
  static const int kEgoOverSpeedToDesiredUnitCostFieldNumber = 2;
  double ego_over_speed_to_desired_unit_cost() const;
  void set_ego_over_speed_to_desired_unit_cost(double value);

  // double ego_desired_speed_tolerate_gap = 3;
  void clear_ego_desired_speed_tolerate_gap();
  static const int kEgoDesiredSpeedTolerateGapFieldNumber = 3;
  double ego_desired_speed_tolerate_gap() const;
  void set_ego_desired_speed_tolerate_gap(double value);

  // double leading_distance_th = 4;
  void clear_leading_distance_th();
  static const int kLeadingDistanceThFieldNumber = 4;
  double leading_distance_th() const;
  void set_leading_distance_th(double value);

  // double min_distance_ratio = 5;
  void clear_min_distance_ratio();
  static const int kMinDistanceRatioFieldNumber = 5;
  double min_distance_ratio() const;
  void set_min_distance_ratio(double value);

  // double ego_speed_blocked_by_leading_unit_cost = 6;
  void clear_ego_speed_blocked_by_leading_unit_cost();
  static const int kEgoSpeedBlockedByLeadingUnitCostFieldNumber = 6;
  double ego_speed_blocked_by_leading_unit_cost() const;
  void set_ego_speed_blocked_by_leading_unit_cost(double value);

  // double leading_speed_blocked_desired_vel_unit_cost = 7;
  void clear_leading_speed_blocked_desired_vel_unit_cost();
  static const int kLeadingSpeedBlockedDesiredVelUnitCostFieldNumber = 7;
  double leading_speed_blocked_desired_vel_unit_cost() const;
  void set_leading_speed_blocked_desired_vel_unit_cost(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.EfficiencyCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ego_lack_speed_to_desired_unit_cost_;
  double ego_over_speed_to_desired_unit_cost_;
  double ego_desired_speed_tolerate_gap_;
  double leading_distance_th_;
  double min_distance_ratio_;
  double ego_speed_blocked_by_leading_unit_cost_;
  double leading_speed_blocked_desired_vel_unit_cost_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SafetyCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.SafetyCost) */ {
 public:
  SafetyCost();
  virtual ~SafetyCost();

  SafetyCost(const SafetyCost& from);

  inline SafetyCost& operator=(const SafetyCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyCost(SafetyCost&& from) noexcept
    : SafetyCost() {
    *this = ::std::move(from);
  }

  inline SafetyCost& operator=(SafetyCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyCost* internal_default_instance() {
    return reinterpret_cast<const SafetyCost*>(
               &_SafetyCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SafetyCost* other);
  friend void swap(SafetyCost& a, SafetyCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyCost* New() const final {
    return CreateMaybeMessage<SafetyCost>(NULL);
  }

  SafetyCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SafetyCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SafetyCost& from);
  void MergeFrom(const SafetyCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafetyCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ego_to_obs = 1;
  void clear_ego_to_obs();
  static const int kEgoToObsFieldNumber = 1;
  double ego_to_obs() const;
  void set_ego_to_obs(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.SafetyCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ego_to_obs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.UserCost) */ {
 public:
  UserCost();
  virtual ~UserCost();

  UserCost(const UserCost& from);

  inline UserCost& operator=(const UserCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserCost(UserCost&& from) noexcept
    : UserCost() {
    *this = ::std::move(from);
  }

  inline UserCost& operator=(UserCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserCost* internal_default_instance() {
    return reinterpret_cast<const UserCost*>(
               &_UserCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UserCost* other);
  friend void swap(UserCost& a, UserCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserCost* New() const final {
    return CreateMaybeMessage<UserCost>(NULL);
  }

  UserCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserCost& from);
  void MergeFrom(const UserCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double late_operate_unit_cost = 1;
  void clear_late_operate_unit_cost();
  static const int kLateOperateUnitCostFieldNumber = 1;
  double late_operate_unit_cost() const;
  void set_late_operate_unit_cost(double value);

  // double cancel_operation_unit_cost = 2;
  void clear_cancel_operation_unit_cost();
  static const int kCancelOperationUnitCostFieldNumber = 2;
  double cancel_operation_unit_cost() const;
  void set_cancel_operation_unit_cost(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.UserCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double late_operate_unit_cost_;
  double cancel_operation_unit_cost_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavigationCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.NavigationCost) */ {
 public:
  NavigationCost();
  virtual ~NavigationCost();

  NavigationCost(const NavigationCost& from);

  inline NavigationCost& operator=(const NavigationCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NavigationCost(NavigationCost&& from) noexcept
    : NavigationCost() {
    *this = ::std::move(from);
  }

  inline NavigationCost& operator=(NavigationCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationCost* internal_default_instance() {
    return reinterpret_cast<const NavigationCost*>(
               &_NavigationCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NavigationCost* other);
  friend void swap(NavigationCost& a, NavigationCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavigationCost* New() const final {
    return CreateMaybeMessage<NavigationCost>(NULL);
  }

  NavigationCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NavigationCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NavigationCost& from);
  void MergeFrom(const NavigationCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ref_line_change = 1;
  void clear_ref_line_change();
  static const int kRefLineChangeFieldNumber = 1;
  double ref_line_change() const;
  void set_ref_line_change(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.NavigationCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ref_line_change_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HdiCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.HdiCost) */ {
 public:
  HdiCost();
  virtual ~HdiCost();

  HdiCost(const HdiCost& from);

  inline HdiCost& operator=(const HdiCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdiCost(HdiCost&& from) noexcept
    : HdiCost() {
    *this = ::std::move(from);
  }

  inline HdiCost& operator=(HdiCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HdiCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdiCost* internal_default_instance() {
    return reinterpret_cast<const HdiCost*>(
               &_HdiCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(HdiCost* other);
  friend void swap(HdiCost& a, HdiCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdiCost* New() const final {
    return CreateMaybeMessage<HdiCost>(NULL);
  }

  HdiCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdiCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdiCost& from);
  void MergeFrom(const HdiCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdiCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double hdi_weight = 1;
  void clear_hdi_weight();
  static const int kHdiWeightFieldNumber = 1;
  double hdi_weight() const;
  void set_hdi_weight(double value);

  // int32 hdi_win_size = 2;
  void clear_hdi_win_size();
  static const int kHdiWinSizeFieldNumber = 2;
  ::google::protobuf::int32 hdi_win_size() const;
  void set_hdi_win_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning.umbp.HdiCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double hdi_weight_;
  ::google::protobuf::int32 hdi_win_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FpbConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.FpbConfig) */ {
 public:
  FpbConfig();
  virtual ~FpbConfig();

  FpbConfig(const FpbConfig& from);

  inline FpbConfig& operator=(const FpbConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FpbConfig(FpbConfig&& from) noexcept
    : FpbConfig() {
    *this = ::std::move(from);
  }

  inline FpbConfig& operator=(FpbConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FpbConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FpbConfig* internal_default_instance() {
    return reinterpret_cast<const FpbConfig*>(
               &_FpbConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FpbConfig* other);
  friend void swap(FpbConfig& a, FpbConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FpbConfig* New() const final {
    return CreateMaybeMessage<FpbConfig>(NULL);
  }

  FpbConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FpbConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FpbConfig& from);
  void MergeFrom(const FpbConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FpbConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double layer_time = 1;
  void clear_layer_time();
  static const int kLayerTimeFieldNumber = 1;
  double layer_time() const;
  void set_layer_time(double value);

  // double step = 2;
  void clear_step();
  static const int kStepFieldNumber = 2;
  double step() const;
  void set_step(double value);

  // double l_ref_to_left_road_bound = 4;
  void clear_l_ref_to_left_road_bound();
  static const int kLRefToLeftRoadBoundFieldNumber = 4;
  double l_ref_to_left_road_bound() const;
  void set_l_ref_to_left_road_bound(double value);

  // double l_ref_to_right_road_bound = 5;
  void clear_l_ref_to_right_road_bound();
  static const int kLRefToRightRoadBoundFieldNumber = 5;
  double l_ref_to_right_road_bound() const;
  void set_l_ref_to_right_road_bound(double value);

  // int32 tree_height = 3;
  void clear_tree_height();
  static const int kTreeHeightFieldNumber = 3;
  ::google::protobuf::int32 tree_height() const;
  void set_tree_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning.umbp.FpbConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double layer_time_;
  double step_;
  double l_ref_to_left_road_bound_;
  double l_ref_to_right_road_bound_;
  ::google::protobuf::int32 tree_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SampleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.SampleConfig) */ {
 public:
  SampleConfig();
  virtual ~SampleConfig();

  SampleConfig(const SampleConfig& from);

  inline SampleConfig& operator=(const SampleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SampleConfig(SampleConfig&& from) noexcept
    : SampleConfig() {
    *this = ::std::move(from);
  }

  inline SampleConfig& operator=(SampleConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SampleConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SampleConfig* internal_default_instance() {
    return reinterpret_cast<const SampleConfig*>(
               &_SampleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SampleConfig* other);
  friend void swap(SampleConfig& a, SampleConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SampleConfig* New() const final {
    return CreateMaybeMessage<SampleConfig>(NULL);
  }

  SampleConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SampleConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SampleConfig& from);
  void MergeFrom(const SampleConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SampleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double s_sample_distance = 1;
  void clear_s_sample_distance();
  static const int kSSampleDistanceFieldNumber = 1;
  double s_sample_distance() const;
  void set_s_sample_distance(double value);

  // double l_sample_distance = 3;
  void clear_l_sample_distance();
  static const int kLSampleDistanceFieldNumber = 3;
  double l_sample_distance() const;
  void set_l_sample_distance(double value);

  // int32 s_sample_num = 2;
  void clear_s_sample_num();
  static const int kSSampleNumFieldNumber = 2;
  ::google::protobuf::int32 s_sample_num() const;
  void set_s_sample_num(::google::protobuf::int32 value);

  // int32 l_sample_num = 4;
  void clear_l_sample_num();
  static const int kLSampleNumFieldNumber = 4;
  ::google::protobuf::int32 l_sample_num() const;
  void set_l_sample_num(::google::protobuf::int32 value);

  // double acc_ref = 5;
  void clear_acc_ref();
  static const int kAccRefFieldNumber = 5;
  double acc_ref() const;
  void set_acc_ref(double value);

  // double dec_ref = 6;
  void clear_dec_ref();
  static const int kDecRefFieldNumber = 6;
  double dec_ref() const;
  void set_dec_ref(double value);

  // double lane_width = 7;
  void clear_lane_width();
  static const int kLaneWidthFieldNumber = 7;
  double lane_width() const;
  void set_lane_width(double value);

  // double increased_sl_distance = 8;
  void clear_increased_sl_distance();
  static const int kIncreasedSlDistanceFieldNumber = 8;
  double increased_sl_distance() const;
  void set_increased_sl_distance(double value);

  // double increased_st_distance = 9;
  void clear_increased_st_distance();
  static const int kIncreasedStDistanceFieldNumber = 9;
  double increased_st_distance() const;
  void set_increased_st_distance(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.SampleConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double s_sample_distance_;
  double l_sample_distance_;
  ::google::protobuf::int32 s_sample_num_;
  ::google::protobuf::int32 l_sample_num_;
  double acc_ref_;
  double dec_ref_;
  double lane_width_;
  double increased_sl_distance_;
  double increased_st_distance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropogateConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.PropogateConfig) */ {
 public:
  PropogateConfig();
  virtual ~PropogateConfig();

  PropogateConfig(const PropogateConfig& from);

  inline PropogateConfig& operator=(const PropogateConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropogateConfig(PropogateConfig&& from) noexcept
    : PropogateConfig() {
    *this = ::std::move(from);
  }

  inline PropogateConfig& operator=(PropogateConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PropogateConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropogateConfig* internal_default_instance() {
    return reinterpret_cast<const PropogateConfig*>(
               &_PropogateConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PropogateConfig* other);
  friend void swap(PropogateConfig& a, PropogateConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropogateConfig* New() const final {
    return CreateMaybeMessage<PropogateConfig>(NULL);
  }

  PropogateConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PropogateConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PropogateConfig& from);
  void MergeFrom(const PropogateConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropogateConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.FpbConfig fpb = 1;
  bool has_fpb() const;
  void clear_fpb();
  static const int kFpbFieldNumber = 1;
  private:
  const ::planning::umbp::FpbConfig& _internal_fpb() const;
  public:
  const ::planning::umbp::FpbConfig& fpb() const;
  ::planning::umbp::FpbConfig* release_fpb();
  ::planning::umbp::FpbConfig* mutable_fpb();
  void set_allocated_fpb(::planning::umbp::FpbConfig* fpb);

  // .planning.umbp.SampleConfig sample = 2;
  bool has_sample() const;
  void clear_sample();
  static const int kSampleFieldNumber = 2;
  private:
  const ::planning::umbp::SampleConfig& _internal_sample() const;
  public:
  const ::planning::umbp::SampleConfig& sample() const;
  ::planning::umbp::SampleConfig* release_sample();
  ::planning::umbp::SampleConfig* mutable_sample();
  void set_allocated_sample(::planning::umbp::SampleConfig* sample);

  // @@protoc_insertion_point(class_scope:planning.umbp.PropogateConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::FpbConfig* fpb_;
  ::planning::umbp::SampleConfig* sample_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CostConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.CostConfig) */ {
 public:
  CostConfig();
  virtual ~CostConfig();

  CostConfig(const CostConfig& from);

  inline CostConfig& operator=(const CostConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CostConfig(CostConfig&& from) noexcept
    : CostConfig() {
    *this = ::std::move(from);
  }

  inline CostConfig& operator=(CostConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CostConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CostConfig* internal_default_instance() {
    return reinterpret_cast<const CostConfig*>(
               &_CostConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CostConfig* other);
  friend void swap(CostConfig& a, CostConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CostConfig* New() const final {
    return CreateMaybeMessage<CostConfig>(NULL);
  }

  CostConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CostConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CostConfig& from);
  void MergeFrom(const CostConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CostConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.EfficiencyCost efficiency = 1;
  bool has_efficiency() const;
  void clear_efficiency();
  static const int kEfficiencyFieldNumber = 1;
  private:
  const ::planning::umbp::EfficiencyCost& _internal_efficiency() const;
  public:
  const ::planning::umbp::EfficiencyCost& efficiency() const;
  ::planning::umbp::EfficiencyCost* release_efficiency();
  ::planning::umbp::EfficiencyCost* mutable_efficiency();
  void set_allocated_efficiency(::planning::umbp::EfficiencyCost* efficiency);

  // .planning.umbp.SafetyCost safety = 2;
  bool has_safety() const;
  void clear_safety();
  static const int kSafetyFieldNumber = 2;
  private:
  const ::planning::umbp::SafetyCost& _internal_safety() const;
  public:
  const ::planning::umbp::SafetyCost& safety() const;
  ::planning::umbp::SafetyCost* release_safety();
  ::planning::umbp::SafetyCost* mutable_safety();
  void set_allocated_safety(::planning::umbp::SafetyCost* safety);

  // .planning.umbp.UserCost user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  private:
  const ::planning::umbp::UserCost& _internal_user() const;
  public:
  const ::planning::umbp::UserCost& user() const;
  ::planning::umbp::UserCost* release_user();
  ::planning::umbp::UserCost* mutable_user();
  void set_allocated_user(::planning::umbp::UserCost* user);

  // .planning.umbp.NavigationCost navigation = 4;
  bool has_navigation() const;
  void clear_navigation();
  static const int kNavigationFieldNumber = 4;
  private:
  const ::planning::umbp::NavigationCost& _internal_navigation() const;
  public:
  const ::planning::umbp::NavigationCost& navigation() const;
  ::planning::umbp::NavigationCost* release_navigation();
  ::planning::umbp::NavigationCost* mutable_navigation();
  void set_allocated_navigation(::planning::umbp::NavigationCost* navigation);

  // .planning.umbp.HdiCost hdi = 6;
  bool has_hdi() const;
  void clear_hdi();
  static const int kHdiFieldNumber = 6;
  private:
  const ::planning::umbp::HdiCost& _internal_hdi() const;
  public:
  const ::planning::umbp::HdiCost& hdi() const;
  ::planning::umbp::HdiCost* release_hdi();
  ::planning::umbp::HdiCost* mutable_hdi();
  void set_allocated_hdi(::planning::umbp::HdiCost* hdi);

  // double discount_factor = 5;
  void clear_discount_factor();
  static const int kDiscountFactorFieldNumber = 5;
  double discount_factor() const;
  void set_discount_factor(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.CostConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::EfficiencyCost* efficiency_;
  ::planning::umbp::SafetyCost* safety_;
  ::planning::umbp::UserCost* user_;
  ::planning::umbp::NavigationCost* navigation_;
  ::planning::umbp::HdiCost* hdi_;
  double discount_factor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.EgoConfig) */ {
 public:
  EgoConfig();
  virtual ~EgoConfig();

  EgoConfig(const EgoConfig& from);

  inline EgoConfig& operator=(const EgoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgoConfig(EgoConfig&& from) noexcept
    : EgoConfig() {
    *this = ::std::move(from);
  }

  inline EgoConfig& operator=(EgoConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EgoConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EgoConfig* internal_default_instance() {
    return reinterpret_cast<const EgoConfig*>(
               &_EgoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(EgoConfig* other);
  friend void swap(EgoConfig& a, EgoConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgoConfig* New() const final {
    return CreateMaybeMessage<EgoConfig>(NULL);
  }

  EgoConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EgoConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EgoConfig& from);
  void MergeFrom(const EgoConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.CarConfig car = 1;
  bool has_car() const;
  void clear_car();
  static const int kCarFieldNumber = 1;
  private:
  const ::planning::umbp::CarConfig& _internal_car() const;
  public:
  const ::planning::umbp::CarConfig& car() const;
  ::planning::umbp::CarConfig* release_car();
  ::planning::umbp::CarConfig* mutable_car();
  void set_allocated_car(::planning::umbp::CarConfig* car);

  // .planning.umbp.MapConfig map = 2;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 2;
  private:
  const ::planning::umbp::MapConfig& _internal_map() const;
  public:
  const ::planning::umbp::MapConfig& map() const;
  ::planning::umbp::MapConfig* release_map();
  ::planning::umbp::MapConfig* mutable_map();
  void set_allocated_map(::planning::umbp::MapConfig* map);

  // @@protoc_insertion_point(class_scope:planning.umbp.EgoConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::CarConfig* car_;
  ::planning::umbp::MapConfig* map_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BezierConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.BezierConfig) */ {
 public:
  BezierConfig();
  virtual ~BezierConfig();

  BezierConfig(const BezierConfig& from);

  inline BezierConfig& operator=(const BezierConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BezierConfig(BezierConfig&& from) noexcept
    : BezierConfig() {
    *this = ::std::move(from);
  }

  inline BezierConfig& operator=(BezierConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BezierConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BezierConfig* internal_default_instance() {
    return reinterpret_cast<const BezierConfig*>(
               &_BezierConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BezierConfig* other);
  friend void swap(BezierConfig& a, BezierConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BezierConfig* New() const final {
    return CreateMaybeMessage<BezierConfig>(NULL);
  }

  BezierConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BezierConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BezierConfig& from);
  void MergeFrom(const BezierConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BezierConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.WeightConfig weight = 1;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 1;
  private:
  const ::planning::umbp::WeightConfig& _internal_weight() const;
  public:
  const ::planning::umbp::WeightConfig& weight() const;
  ::planning::umbp::WeightConfig* release_weight();
  ::planning::umbp::WeightConfig* mutable_weight();
  void set_allocated_weight(::planning::umbp::WeightConfig* weight);

  // .planning.umbp.CubeConfig cube = 2;
  bool has_cube() const;
  void clear_cube();
  static const int kCubeFieldNumber = 2;
  private:
  const ::planning::umbp::CubeConfig& _internal_cube() const;
  public:
  const ::planning::umbp::CubeConfig& cube() const;
  ::planning::umbp::CubeConfig* release_cube();
  ::planning::umbp::CubeConfig* mutable_cube();
  void set_allocated_cube(::planning::umbp::CubeConfig* cube);

  // @@protoc_insertion_point(class_scope:planning.umbp.BezierConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::WeightConfig* weight_;
  ::planning::umbp::CubeConfig* cube_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeightConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.WeightConfig) */ {
 public:
  WeightConfig();
  virtual ~WeightConfig();

  WeightConfig(const WeightConfig& from);

  inline WeightConfig& operator=(const WeightConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WeightConfig(WeightConfig&& from) noexcept
    : WeightConfig() {
    *this = ::std::move(from);
  }

  inline WeightConfig& operator=(WeightConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WeightConfig* internal_default_instance() {
    return reinterpret_cast<const WeightConfig*>(
               &_WeightConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(WeightConfig* other);
  friend void swap(WeightConfig& a, WeightConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WeightConfig* New() const final {
    return CreateMaybeMessage<WeightConfig>(NULL);
  }

  WeightConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WeightConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WeightConfig& from);
  void MergeFrom(const WeightConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeightConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double weight_P = 1;
  void clear_weight_p();
  static const int kWeightPFieldNumber = 1;
  double weight_p() const;
  void set_weight_p(double value);

  // double weight_c = 2;
  void clear_weight_c();
  static const int kWeightCFieldNumber = 2;
  double weight_c() const;
  void set_weight_c(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.WeightConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double weight_p_;
  double weight_c_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CubeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.CubeConfig) */ {
 public:
  CubeConfig();
  virtual ~CubeConfig();

  CubeConfig(const CubeConfig& from);

  inline CubeConfig& operator=(const CubeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CubeConfig(CubeConfig&& from) noexcept
    : CubeConfig() {
    *this = ::std::move(from);
  }

  inline CubeConfig& operator=(CubeConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CubeConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CubeConfig* internal_default_instance() {
    return reinterpret_cast<const CubeConfig*>(
               &_CubeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CubeConfig* other);
  friend void swap(CubeConfig& a, CubeConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CubeConfig* New() const final {
    return CreateMaybeMessage<CubeConfig>(NULL);
  }

  CubeConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CubeConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CubeConfig& from);
  void MergeFrom(const CubeConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CubeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double v_lb_s = 1;
  void clear_v_lb_s();
  static const int kVLbSFieldNumber = 1;
  double v_lb_s() const;
  void set_v_lb_s(double value);

  // double v_lb_l = 2;
  void clear_v_lb_l();
  static const int kVLbLFieldNumber = 2;
  double v_lb_l() const;
  void set_v_lb_l(double value);

  // double v_ub_s = 3;
  void clear_v_ub_s();
  static const int kVUbSFieldNumber = 3;
  double v_ub_s() const;
  void set_v_ub_s(double value);

  // double v_ub_l = 4;
  void clear_v_ub_l();
  static const int kVUbLFieldNumber = 4;
  double v_ub_l() const;
  void set_v_ub_l(double value);

  // double a_lb_s = 5;
  void clear_a_lb_s();
  static const int kALbSFieldNumber = 5;
  double a_lb_s() const;
  void set_a_lb_s(double value);

  // double a_lb_l = 6;
  void clear_a_lb_l();
  static const int kALbLFieldNumber = 6;
  double a_lb_l() const;
  void set_a_lb_l(double value);

  // double a_ub_s = 7;
  void clear_a_ub_s();
  static const int kAUbSFieldNumber = 7;
  double a_ub_s() const;
  void set_a_ub_s(double value);

  // double a_ub_l = 8;
  void clear_a_ub_l();
  static const int kAUbLFieldNumber = 8;
  double a_ub_l() const;
  void set_a_ub_l(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.CubeConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double v_lb_s_;
  double v_lb_l_;
  double v_ub_s_;
  double v_ub_l_;
  double a_lb_s_;
  double a_lb_l_;
  double a_ub_s_;
  double a_ub_l_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CarConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.CarConfig) */ {
 public:
  CarConfig();
  virtual ~CarConfig();

  CarConfig(const CarConfig& from);

  inline CarConfig& operator=(const CarConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CarConfig(CarConfig&& from) noexcept
    : CarConfig() {
    *this = ::std::move(from);
  }

  inline CarConfig& operator=(CarConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CarConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarConfig* internal_default_instance() {
    return reinterpret_cast<const CarConfig*>(
               &_CarConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CarConfig* other);
  friend void swap(CarConfig& a, CarConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CarConfig* New() const final {
    return CreateMaybeMessage<CarConfig>(NULL);
  }

  CarConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CarConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CarConfig& from);
  void MergeFrom(const CarConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double car_width = 1;
  void clear_car_width();
  static const int kCarWidthFieldNumber = 1;
  double car_width() const;
  void set_car_width(double value);

  // double car_length = 2;
  void clear_car_length();
  static const int kCarLengthFieldNumber = 2;
  double car_length() const;
  void set_car_length(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.CarConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double car_width_;
  double car_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.MapConfig) */ {
 public:
  MapConfig();
  virtual ~MapConfig();

  MapConfig(const MapConfig& from);

  inline MapConfig& operator=(const MapConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapConfig(MapConfig&& from) noexcept
    : MapConfig() {
    *this = ::std::move(from);
  }

  inline MapConfig& operator=(MapConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapConfig* internal_default_instance() {
    return reinterpret_cast<const MapConfig*>(
               &_MapConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MapConfig* other);
  friend void swap(MapConfig& a, MapConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapConfig* New() const final {
    return CreateMaybeMessage<MapConfig>(NULL);
  }

  MapConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapConfig& from);
  void MergeFrom(const MapConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double reference_speed = 1;
  void clear_reference_speed();
  static const int kReferenceSpeedFieldNumber = 1;
  double reference_speed() const;
  void set_reference_speed(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.MapConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double reference_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(NULL);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // .planning.umbp.CostConfig cost = 4;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  private:
  const ::planning::umbp::CostConfig& _internal_cost() const;
  public:
  const ::planning::umbp::CostConfig& cost() const;
  ::planning::umbp::CostConfig* release_cost();
  ::planning::umbp::CostConfig* mutable_cost();
  void set_allocated_cost(::planning::umbp::CostConfig* cost);

  // .planning.umbp.PropogateConfig propogate = 5;
  bool has_propogate() const;
  void clear_propogate();
  static const int kPropogateFieldNumber = 5;
  private:
  const ::planning::umbp::PropogateConfig& _internal_propogate() const;
  public:
  const ::planning::umbp::PropogateConfig& propogate() const;
  ::planning::umbp::PropogateConfig* release_propogate();
  ::planning::umbp::PropogateConfig* mutable_propogate();
  void set_allocated_propogate(::planning::umbp::PropogateConfig* propogate);

  // .planning.umbp.EgoConfig ego = 6;
  bool has_ego() const;
  void clear_ego();
  static const int kEgoFieldNumber = 6;
  private:
  const ::planning::umbp::EgoConfig& _internal_ego() const;
  public:
  const ::planning::umbp::EgoConfig& ego() const;
  ::planning::umbp::EgoConfig* release_ego();
  ::planning::umbp::EgoConfig* mutable_ego();
  void set_allocated_ego(::planning::umbp::EgoConfig* ego);

  // .planning.umbp.BezierConfig bezier = 7;
  bool has_bezier() const;
  void clear_bezier();
  static const int kBezierFieldNumber = 7;
  private:
  const ::planning::umbp::BezierConfig& _internal_bezier() const;
  public:
  const ::planning::umbp::BezierConfig& bezier() const;
  ::planning::umbp::BezierConfig* release_bezier();
  ::planning::umbp::BezierConfig* mutable_bezier();
  void set_allocated_bezier(::planning::umbp::BezierConfig* bezier);

  // @@protoc_insertion_point(class_scope:planning.umbp.Config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::planning::umbp::CostConfig* cost_;
  ::planning::umbp::PropogateConfig* propogate_;
  ::planning::umbp::EgoConfig* ego_;
  ::planning::umbp::BezierConfig* bezier_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EfficiencyCost

// double ego_lack_speed_to_desired_unit_cost = 1;
inline void EfficiencyCost::clear_ego_lack_speed_to_desired_unit_cost() {
  ego_lack_speed_to_desired_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_lack_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_lack_speed_to_desired_unit_cost)
  return ego_lack_speed_to_desired_unit_cost_;
}
inline void EfficiencyCost::set_ego_lack_speed_to_desired_unit_cost(double value) {
  
  ego_lack_speed_to_desired_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_lack_speed_to_desired_unit_cost)
}

// double ego_over_speed_to_desired_unit_cost = 2;
inline void EfficiencyCost::clear_ego_over_speed_to_desired_unit_cost() {
  ego_over_speed_to_desired_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_over_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_over_speed_to_desired_unit_cost)
  return ego_over_speed_to_desired_unit_cost_;
}
inline void EfficiencyCost::set_ego_over_speed_to_desired_unit_cost(double value) {
  
  ego_over_speed_to_desired_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_over_speed_to_desired_unit_cost)
}

// double ego_desired_speed_tolerate_gap = 3;
inline void EfficiencyCost::clear_ego_desired_speed_tolerate_gap() {
  ego_desired_speed_tolerate_gap_ = 0;
}
inline double EfficiencyCost::ego_desired_speed_tolerate_gap() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_desired_speed_tolerate_gap)
  return ego_desired_speed_tolerate_gap_;
}
inline void EfficiencyCost::set_ego_desired_speed_tolerate_gap(double value) {
  
  ego_desired_speed_tolerate_gap_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_desired_speed_tolerate_gap)
}

// double leading_distance_th = 4;
inline void EfficiencyCost::clear_leading_distance_th() {
  leading_distance_th_ = 0;
}
inline double EfficiencyCost::leading_distance_th() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.leading_distance_th)
  return leading_distance_th_;
}
inline void EfficiencyCost::set_leading_distance_th(double value) {
  
  leading_distance_th_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.leading_distance_th)
}

// double min_distance_ratio = 5;
inline void EfficiencyCost::clear_min_distance_ratio() {
  min_distance_ratio_ = 0;
}
inline double EfficiencyCost::min_distance_ratio() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.min_distance_ratio)
  return min_distance_ratio_;
}
inline void EfficiencyCost::set_min_distance_ratio(double value) {
  
  min_distance_ratio_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.min_distance_ratio)
}

// double ego_speed_blocked_by_leading_unit_cost = 6;
inline void EfficiencyCost::clear_ego_speed_blocked_by_leading_unit_cost() {
  ego_speed_blocked_by_leading_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_speed_blocked_by_leading_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_speed_blocked_by_leading_unit_cost)
  return ego_speed_blocked_by_leading_unit_cost_;
}
inline void EfficiencyCost::set_ego_speed_blocked_by_leading_unit_cost(double value) {
  
  ego_speed_blocked_by_leading_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_speed_blocked_by_leading_unit_cost)
}

// double leading_speed_blocked_desired_vel_unit_cost = 7;
inline void EfficiencyCost::clear_leading_speed_blocked_desired_vel_unit_cost() {
  leading_speed_blocked_desired_vel_unit_cost_ = 0;
}
inline double EfficiencyCost::leading_speed_blocked_desired_vel_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.leading_speed_blocked_desired_vel_unit_cost)
  return leading_speed_blocked_desired_vel_unit_cost_;
}
inline void EfficiencyCost::set_leading_speed_blocked_desired_vel_unit_cost(double value) {
  
  leading_speed_blocked_desired_vel_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.leading_speed_blocked_desired_vel_unit_cost)
}

// -------------------------------------------------------------------

// SafetyCost

// double ego_to_obs = 1;
inline void SafetyCost::clear_ego_to_obs() {
  ego_to_obs_ = 0;
}
inline double SafetyCost::ego_to_obs() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SafetyCost.ego_to_obs)
  return ego_to_obs_;
}
inline void SafetyCost::set_ego_to_obs(double value) {
  
  ego_to_obs_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SafetyCost.ego_to_obs)
}

// -------------------------------------------------------------------

// UserCost

// double late_operate_unit_cost = 1;
inline void UserCost::clear_late_operate_unit_cost() {
  late_operate_unit_cost_ = 0;
}
inline double UserCost::late_operate_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.UserCost.late_operate_unit_cost)
  return late_operate_unit_cost_;
}
inline void UserCost::set_late_operate_unit_cost(double value) {
  
  late_operate_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.UserCost.late_operate_unit_cost)
}

// double cancel_operation_unit_cost = 2;
inline void UserCost::clear_cancel_operation_unit_cost() {
  cancel_operation_unit_cost_ = 0;
}
inline double UserCost::cancel_operation_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.UserCost.cancel_operation_unit_cost)
  return cancel_operation_unit_cost_;
}
inline void UserCost::set_cancel_operation_unit_cost(double value) {
  
  cancel_operation_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.UserCost.cancel_operation_unit_cost)
}

// -------------------------------------------------------------------

// NavigationCost

// double ref_line_change = 1;
inline void NavigationCost::clear_ref_line_change() {
  ref_line_change_ = 0;
}
inline double NavigationCost::ref_line_change() const {
  // @@protoc_insertion_point(field_get:planning.umbp.NavigationCost.ref_line_change)
  return ref_line_change_;
}
inline void NavigationCost::set_ref_line_change(double value) {
  
  ref_line_change_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.NavigationCost.ref_line_change)
}

// -------------------------------------------------------------------

// HdiCost

// double hdi_weight = 1;
inline void HdiCost::clear_hdi_weight() {
  hdi_weight_ = 0;
}
inline double HdiCost::hdi_weight() const {
  // @@protoc_insertion_point(field_get:planning.umbp.HdiCost.hdi_weight)
  return hdi_weight_;
}
inline void HdiCost::set_hdi_weight(double value) {
  
  hdi_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.HdiCost.hdi_weight)
}

// int32 hdi_win_size = 2;
inline void HdiCost::clear_hdi_win_size() {
  hdi_win_size_ = 0;
}
inline ::google::protobuf::int32 HdiCost::hdi_win_size() const {
  // @@protoc_insertion_point(field_get:planning.umbp.HdiCost.hdi_win_size)
  return hdi_win_size_;
}
inline void HdiCost::set_hdi_win_size(::google::protobuf::int32 value) {
  
  hdi_win_size_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.HdiCost.hdi_win_size)
}

// -------------------------------------------------------------------

// FpbConfig

// double layer_time = 1;
inline void FpbConfig::clear_layer_time() {
  layer_time_ = 0;
}
inline double FpbConfig::layer_time() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.layer_time)
  return layer_time_;
}
inline void FpbConfig::set_layer_time(double value) {
  
  layer_time_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.layer_time)
}

// double step = 2;
inline void FpbConfig::clear_step() {
  step_ = 0;
}
inline double FpbConfig::step() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.step)
  return step_;
}
inline void FpbConfig::set_step(double value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.step)
}

// int32 tree_height = 3;
inline void FpbConfig::clear_tree_height() {
  tree_height_ = 0;
}
inline ::google::protobuf::int32 FpbConfig::tree_height() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.tree_height)
  return tree_height_;
}
inline void FpbConfig::set_tree_height(::google::protobuf::int32 value) {
  
  tree_height_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.tree_height)
}

// double l_ref_to_left_road_bound = 4;
inline void FpbConfig::clear_l_ref_to_left_road_bound() {
  l_ref_to_left_road_bound_ = 0;
}
inline double FpbConfig::l_ref_to_left_road_bound() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.l_ref_to_left_road_bound)
  return l_ref_to_left_road_bound_;
}
inline void FpbConfig::set_l_ref_to_left_road_bound(double value) {
  
  l_ref_to_left_road_bound_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.l_ref_to_left_road_bound)
}

// double l_ref_to_right_road_bound = 5;
inline void FpbConfig::clear_l_ref_to_right_road_bound() {
  l_ref_to_right_road_bound_ = 0;
}
inline double FpbConfig::l_ref_to_right_road_bound() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.l_ref_to_right_road_bound)
  return l_ref_to_right_road_bound_;
}
inline void FpbConfig::set_l_ref_to_right_road_bound(double value) {
  
  l_ref_to_right_road_bound_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.l_ref_to_right_road_bound)
}

// -------------------------------------------------------------------

// SampleConfig

// double s_sample_distance = 1;
inline void SampleConfig::clear_s_sample_distance() {
  s_sample_distance_ = 0;
}
inline double SampleConfig::s_sample_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.s_sample_distance)
  return s_sample_distance_;
}
inline void SampleConfig::set_s_sample_distance(double value) {
  
  s_sample_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.s_sample_distance)
}

// int32 s_sample_num = 2;
inline void SampleConfig::clear_s_sample_num() {
  s_sample_num_ = 0;
}
inline ::google::protobuf::int32 SampleConfig::s_sample_num() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.s_sample_num)
  return s_sample_num_;
}
inline void SampleConfig::set_s_sample_num(::google::protobuf::int32 value) {
  
  s_sample_num_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.s_sample_num)
}

// double l_sample_distance = 3;
inline void SampleConfig::clear_l_sample_distance() {
  l_sample_distance_ = 0;
}
inline double SampleConfig::l_sample_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.l_sample_distance)
  return l_sample_distance_;
}
inline void SampleConfig::set_l_sample_distance(double value) {
  
  l_sample_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.l_sample_distance)
}

// int32 l_sample_num = 4;
inline void SampleConfig::clear_l_sample_num() {
  l_sample_num_ = 0;
}
inline ::google::protobuf::int32 SampleConfig::l_sample_num() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.l_sample_num)
  return l_sample_num_;
}
inline void SampleConfig::set_l_sample_num(::google::protobuf::int32 value) {
  
  l_sample_num_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.l_sample_num)
}

// double acc_ref = 5;
inline void SampleConfig::clear_acc_ref() {
  acc_ref_ = 0;
}
inline double SampleConfig::acc_ref() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.acc_ref)
  return acc_ref_;
}
inline void SampleConfig::set_acc_ref(double value) {
  
  acc_ref_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.acc_ref)
}

// double dec_ref = 6;
inline void SampleConfig::clear_dec_ref() {
  dec_ref_ = 0;
}
inline double SampleConfig::dec_ref() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.dec_ref)
  return dec_ref_;
}
inline void SampleConfig::set_dec_ref(double value) {
  
  dec_ref_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.dec_ref)
}

// double lane_width = 7;
inline void SampleConfig::clear_lane_width() {
  lane_width_ = 0;
}
inline double SampleConfig::lane_width() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.lane_width)
  return lane_width_;
}
inline void SampleConfig::set_lane_width(double value) {
  
  lane_width_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.lane_width)
}

// double increased_sl_distance = 8;
inline void SampleConfig::clear_increased_sl_distance() {
  increased_sl_distance_ = 0;
}
inline double SampleConfig::increased_sl_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.increased_sl_distance)
  return increased_sl_distance_;
}
inline void SampleConfig::set_increased_sl_distance(double value) {
  
  increased_sl_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.increased_sl_distance)
}

// double increased_st_distance = 9;
inline void SampleConfig::clear_increased_st_distance() {
  increased_st_distance_ = 0;
}
inline double SampleConfig::increased_st_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.increased_st_distance)
  return increased_st_distance_;
}
inline void SampleConfig::set_increased_st_distance(double value) {
  
  increased_st_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.increased_st_distance)
}

// -------------------------------------------------------------------

// PropogateConfig

// .planning.umbp.FpbConfig fpb = 1;
inline bool PropogateConfig::has_fpb() const {
  return this != internal_default_instance() && fpb_ != NULL;
}
inline void PropogateConfig::clear_fpb() {
  if (GetArenaNoVirtual() == NULL && fpb_ != NULL) {
    delete fpb_;
  }
  fpb_ = NULL;
}
inline const ::planning::umbp::FpbConfig& PropogateConfig::_internal_fpb() const {
  return *fpb_;
}
inline const ::planning::umbp::FpbConfig& PropogateConfig::fpb() const {
  const ::planning::umbp::FpbConfig* p = fpb_;
  // @@protoc_insertion_point(field_get:planning.umbp.PropogateConfig.fpb)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::FpbConfig*>(
      &::planning::umbp::_FpbConfig_default_instance_);
}
inline ::planning::umbp::FpbConfig* PropogateConfig::release_fpb() {
  // @@protoc_insertion_point(field_release:planning.umbp.PropogateConfig.fpb)
  
  ::planning::umbp::FpbConfig* temp = fpb_;
  fpb_ = NULL;
  return temp;
}
inline ::planning::umbp::FpbConfig* PropogateConfig::mutable_fpb() {
  
  if (fpb_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::FpbConfig>(GetArenaNoVirtual());
    fpb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.PropogateConfig.fpb)
  return fpb_;
}
inline void PropogateConfig::set_allocated_fpb(::planning::umbp::FpbConfig* fpb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fpb_;
  }
  if (fpb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fpb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fpb, submessage_arena);
    }
    
  } else {
    
  }
  fpb_ = fpb;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.PropogateConfig.fpb)
}

// .planning.umbp.SampleConfig sample = 2;
inline bool PropogateConfig::has_sample() const {
  return this != internal_default_instance() && sample_ != NULL;
}
inline void PropogateConfig::clear_sample() {
  if (GetArenaNoVirtual() == NULL && sample_ != NULL) {
    delete sample_;
  }
  sample_ = NULL;
}
inline const ::planning::umbp::SampleConfig& PropogateConfig::_internal_sample() const {
  return *sample_;
}
inline const ::planning::umbp::SampleConfig& PropogateConfig::sample() const {
  const ::planning::umbp::SampleConfig* p = sample_;
  // @@protoc_insertion_point(field_get:planning.umbp.PropogateConfig.sample)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::SampleConfig*>(
      &::planning::umbp::_SampleConfig_default_instance_);
}
inline ::planning::umbp::SampleConfig* PropogateConfig::release_sample() {
  // @@protoc_insertion_point(field_release:planning.umbp.PropogateConfig.sample)
  
  ::planning::umbp::SampleConfig* temp = sample_;
  sample_ = NULL;
  return temp;
}
inline ::planning::umbp::SampleConfig* PropogateConfig::mutable_sample() {
  
  if (sample_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::SampleConfig>(GetArenaNoVirtual());
    sample_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.PropogateConfig.sample)
  return sample_;
}
inline void PropogateConfig::set_allocated_sample(::planning::umbp::SampleConfig* sample) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sample_;
  }
  if (sample) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sample = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sample, submessage_arena);
    }
    
  } else {
    
  }
  sample_ = sample;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.PropogateConfig.sample)
}

// -------------------------------------------------------------------

// CostConfig

// .planning.umbp.EfficiencyCost efficiency = 1;
inline bool CostConfig::has_efficiency() const {
  return this != internal_default_instance() && efficiency_ != NULL;
}
inline void CostConfig::clear_efficiency() {
  if (GetArenaNoVirtual() == NULL && efficiency_ != NULL) {
    delete efficiency_;
  }
  efficiency_ = NULL;
}
inline const ::planning::umbp::EfficiencyCost& CostConfig::_internal_efficiency() const {
  return *efficiency_;
}
inline const ::planning::umbp::EfficiencyCost& CostConfig::efficiency() const {
  const ::planning::umbp::EfficiencyCost* p = efficiency_;
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.efficiency)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::EfficiencyCost*>(
      &::planning::umbp::_EfficiencyCost_default_instance_);
}
inline ::planning::umbp::EfficiencyCost* CostConfig::release_efficiency() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.efficiency)
  
  ::planning::umbp::EfficiencyCost* temp = efficiency_;
  efficiency_ = NULL;
  return temp;
}
inline ::planning::umbp::EfficiencyCost* CostConfig::mutable_efficiency() {
  
  if (efficiency_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::EfficiencyCost>(GetArenaNoVirtual());
    efficiency_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.efficiency)
  return efficiency_;
}
inline void CostConfig::set_allocated_efficiency(::planning::umbp::EfficiencyCost* efficiency) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete efficiency_;
  }
  if (efficiency) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      efficiency = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, efficiency, submessage_arena);
    }
    
  } else {
    
  }
  efficiency_ = efficiency;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.efficiency)
}

// .planning.umbp.SafetyCost safety = 2;
inline bool CostConfig::has_safety() const {
  return this != internal_default_instance() && safety_ != NULL;
}
inline void CostConfig::clear_safety() {
  if (GetArenaNoVirtual() == NULL && safety_ != NULL) {
    delete safety_;
  }
  safety_ = NULL;
}
inline const ::planning::umbp::SafetyCost& CostConfig::_internal_safety() const {
  return *safety_;
}
inline const ::planning::umbp::SafetyCost& CostConfig::safety() const {
  const ::planning::umbp::SafetyCost* p = safety_;
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.safety)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::SafetyCost*>(
      &::planning::umbp::_SafetyCost_default_instance_);
}
inline ::planning::umbp::SafetyCost* CostConfig::release_safety() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.safety)
  
  ::planning::umbp::SafetyCost* temp = safety_;
  safety_ = NULL;
  return temp;
}
inline ::planning::umbp::SafetyCost* CostConfig::mutable_safety() {
  
  if (safety_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::SafetyCost>(GetArenaNoVirtual());
    safety_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.safety)
  return safety_;
}
inline void CostConfig::set_allocated_safety(::planning::umbp::SafetyCost* safety) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete safety_;
  }
  if (safety) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      safety = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, safety, submessage_arena);
    }
    
  } else {
    
  }
  safety_ = safety;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.safety)
}

// .planning.umbp.UserCost user = 3;
inline bool CostConfig::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void CostConfig::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) {
    delete user_;
  }
  user_ = NULL;
}
inline const ::planning::umbp::UserCost& CostConfig::_internal_user() const {
  return *user_;
}
inline const ::planning::umbp::UserCost& CostConfig::user() const {
  const ::planning::umbp::UserCost* p = user_;
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.user)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::UserCost*>(
      &::planning::umbp::_UserCost_default_instance_);
}
inline ::planning::umbp::UserCost* CostConfig::release_user() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.user)
  
  ::planning::umbp::UserCost* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::planning::umbp::UserCost* CostConfig::mutable_user() {
  
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::UserCost>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.user)
  return user_;
}
inline void CostConfig::set_allocated_user(::planning::umbp::UserCost* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.user)
}

// .planning.umbp.NavigationCost navigation = 4;
inline bool CostConfig::has_navigation() const {
  return this != internal_default_instance() && navigation_ != NULL;
}
inline void CostConfig::clear_navigation() {
  if (GetArenaNoVirtual() == NULL && navigation_ != NULL) {
    delete navigation_;
  }
  navigation_ = NULL;
}
inline const ::planning::umbp::NavigationCost& CostConfig::_internal_navigation() const {
  return *navigation_;
}
inline const ::planning::umbp::NavigationCost& CostConfig::navigation() const {
  const ::planning::umbp::NavigationCost* p = navigation_;
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.navigation)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::NavigationCost*>(
      &::planning::umbp::_NavigationCost_default_instance_);
}
inline ::planning::umbp::NavigationCost* CostConfig::release_navigation() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.navigation)
  
  ::planning::umbp::NavigationCost* temp = navigation_;
  navigation_ = NULL;
  return temp;
}
inline ::planning::umbp::NavigationCost* CostConfig::mutable_navigation() {
  
  if (navigation_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::NavigationCost>(GetArenaNoVirtual());
    navigation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.navigation)
  return navigation_;
}
inline void CostConfig::set_allocated_navigation(::planning::umbp::NavigationCost* navigation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete navigation_;
  }
  if (navigation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navigation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navigation, submessage_arena);
    }
    
  } else {
    
  }
  navigation_ = navigation;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.navigation)
}

// double discount_factor = 5;
inline void CostConfig::clear_discount_factor() {
  discount_factor_ = 0;
}
inline double CostConfig::discount_factor() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.discount_factor)
  return discount_factor_;
}
inline void CostConfig::set_discount_factor(double value) {
  
  discount_factor_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CostConfig.discount_factor)
}

// .planning.umbp.HdiCost hdi = 6;
inline bool CostConfig::has_hdi() const {
  return this != internal_default_instance() && hdi_ != NULL;
}
inline void CostConfig::clear_hdi() {
  if (GetArenaNoVirtual() == NULL && hdi_ != NULL) {
    delete hdi_;
  }
  hdi_ = NULL;
}
inline const ::planning::umbp::HdiCost& CostConfig::_internal_hdi() const {
  return *hdi_;
}
inline const ::planning::umbp::HdiCost& CostConfig::hdi() const {
  const ::planning::umbp::HdiCost* p = hdi_;
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.hdi)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::HdiCost*>(
      &::planning::umbp::_HdiCost_default_instance_);
}
inline ::planning::umbp::HdiCost* CostConfig::release_hdi() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.hdi)
  
  ::planning::umbp::HdiCost* temp = hdi_;
  hdi_ = NULL;
  return temp;
}
inline ::planning::umbp::HdiCost* CostConfig::mutable_hdi() {
  
  if (hdi_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::HdiCost>(GetArenaNoVirtual());
    hdi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.hdi)
  return hdi_;
}
inline void CostConfig::set_allocated_hdi(::planning::umbp::HdiCost* hdi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hdi_;
  }
  if (hdi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hdi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hdi, submessage_arena);
    }
    
  } else {
    
  }
  hdi_ = hdi;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.hdi)
}

// -------------------------------------------------------------------

// EgoConfig

// .planning.umbp.CarConfig car = 1;
inline bool EgoConfig::has_car() const {
  return this != internal_default_instance() && car_ != NULL;
}
inline void EgoConfig::clear_car() {
  if (GetArenaNoVirtual() == NULL && car_ != NULL) {
    delete car_;
  }
  car_ = NULL;
}
inline const ::planning::umbp::CarConfig& EgoConfig::_internal_car() const {
  return *car_;
}
inline const ::planning::umbp::CarConfig& EgoConfig::car() const {
  const ::planning::umbp::CarConfig* p = car_;
  // @@protoc_insertion_point(field_get:planning.umbp.EgoConfig.car)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::CarConfig*>(
      &::planning::umbp::_CarConfig_default_instance_);
}
inline ::planning::umbp::CarConfig* EgoConfig::release_car() {
  // @@protoc_insertion_point(field_release:planning.umbp.EgoConfig.car)
  
  ::planning::umbp::CarConfig* temp = car_;
  car_ = NULL;
  return temp;
}
inline ::planning::umbp::CarConfig* EgoConfig::mutable_car() {
  
  if (car_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::CarConfig>(GetArenaNoVirtual());
    car_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.EgoConfig.car)
  return car_;
}
inline void EgoConfig::set_allocated_car(::planning::umbp::CarConfig* car) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete car_;
  }
  if (car) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      car = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, car, submessage_arena);
    }
    
  } else {
    
  }
  car_ = car;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.EgoConfig.car)
}

// .planning.umbp.MapConfig map = 2;
inline bool EgoConfig::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void EgoConfig::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) {
    delete map_;
  }
  map_ = NULL;
}
inline const ::planning::umbp::MapConfig& EgoConfig::_internal_map() const {
  return *map_;
}
inline const ::planning::umbp::MapConfig& EgoConfig::map() const {
  const ::planning::umbp::MapConfig* p = map_;
  // @@protoc_insertion_point(field_get:planning.umbp.EgoConfig.map)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::MapConfig*>(
      &::planning::umbp::_MapConfig_default_instance_);
}
inline ::planning::umbp::MapConfig* EgoConfig::release_map() {
  // @@protoc_insertion_point(field_release:planning.umbp.EgoConfig.map)
  
  ::planning::umbp::MapConfig* temp = map_;
  map_ = NULL;
  return temp;
}
inline ::planning::umbp::MapConfig* EgoConfig::mutable_map() {
  
  if (map_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::MapConfig>(GetArenaNoVirtual());
    map_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.EgoConfig.map)
  return map_;
}
inline void EgoConfig::set_allocated_map(::planning::umbp::MapConfig* map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_;
  }
  if (map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    
  } else {
    
  }
  map_ = map;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.EgoConfig.map)
}

// -------------------------------------------------------------------

// BezierConfig

// .planning.umbp.WeightConfig weight = 1;
inline bool BezierConfig::has_weight() const {
  return this != internal_default_instance() && weight_ != NULL;
}
inline void BezierConfig::clear_weight() {
  if (GetArenaNoVirtual() == NULL && weight_ != NULL) {
    delete weight_;
  }
  weight_ = NULL;
}
inline const ::planning::umbp::WeightConfig& BezierConfig::_internal_weight() const {
  return *weight_;
}
inline const ::planning::umbp::WeightConfig& BezierConfig::weight() const {
  const ::planning::umbp::WeightConfig* p = weight_;
  // @@protoc_insertion_point(field_get:planning.umbp.BezierConfig.weight)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::WeightConfig*>(
      &::planning::umbp::_WeightConfig_default_instance_);
}
inline ::planning::umbp::WeightConfig* BezierConfig::release_weight() {
  // @@protoc_insertion_point(field_release:planning.umbp.BezierConfig.weight)
  
  ::planning::umbp::WeightConfig* temp = weight_;
  weight_ = NULL;
  return temp;
}
inline ::planning::umbp::WeightConfig* BezierConfig::mutable_weight() {
  
  if (weight_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::WeightConfig>(GetArenaNoVirtual());
    weight_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.BezierConfig.weight)
  return weight_;
}
inline void BezierConfig::set_allocated_weight(::planning::umbp::WeightConfig* weight) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete weight_;
  }
  if (weight) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      weight = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, weight, submessage_arena);
    }
    
  } else {
    
  }
  weight_ = weight;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.BezierConfig.weight)
}

// .planning.umbp.CubeConfig cube = 2;
inline bool BezierConfig::has_cube() const {
  return this != internal_default_instance() && cube_ != NULL;
}
inline void BezierConfig::clear_cube() {
  if (GetArenaNoVirtual() == NULL && cube_ != NULL) {
    delete cube_;
  }
  cube_ = NULL;
}
inline const ::planning::umbp::CubeConfig& BezierConfig::_internal_cube() const {
  return *cube_;
}
inline const ::planning::umbp::CubeConfig& BezierConfig::cube() const {
  const ::planning::umbp::CubeConfig* p = cube_;
  // @@protoc_insertion_point(field_get:planning.umbp.BezierConfig.cube)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::CubeConfig*>(
      &::planning::umbp::_CubeConfig_default_instance_);
}
inline ::planning::umbp::CubeConfig* BezierConfig::release_cube() {
  // @@protoc_insertion_point(field_release:planning.umbp.BezierConfig.cube)
  
  ::planning::umbp::CubeConfig* temp = cube_;
  cube_ = NULL;
  return temp;
}
inline ::planning::umbp::CubeConfig* BezierConfig::mutable_cube() {
  
  if (cube_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::CubeConfig>(GetArenaNoVirtual());
    cube_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.BezierConfig.cube)
  return cube_;
}
inline void BezierConfig::set_allocated_cube(::planning::umbp::CubeConfig* cube) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cube_;
  }
  if (cube) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cube = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cube, submessage_arena);
    }
    
  } else {
    
  }
  cube_ = cube;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.BezierConfig.cube)
}

// -------------------------------------------------------------------

// WeightConfig

// double weight_P = 1;
inline void WeightConfig::clear_weight_p() {
  weight_p_ = 0;
}
inline double WeightConfig::weight_p() const {
  // @@protoc_insertion_point(field_get:planning.umbp.WeightConfig.weight_P)
  return weight_p_;
}
inline void WeightConfig::set_weight_p(double value) {
  
  weight_p_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.WeightConfig.weight_P)
}

// double weight_c = 2;
inline void WeightConfig::clear_weight_c() {
  weight_c_ = 0;
}
inline double WeightConfig::weight_c() const {
  // @@protoc_insertion_point(field_get:planning.umbp.WeightConfig.weight_c)
  return weight_c_;
}
inline void WeightConfig::set_weight_c(double value) {
  
  weight_c_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.WeightConfig.weight_c)
}

// -------------------------------------------------------------------

// CubeConfig

// double v_lb_s = 1;
inline void CubeConfig::clear_v_lb_s() {
  v_lb_s_ = 0;
}
inline double CubeConfig::v_lb_s() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.v_lb_s)
  return v_lb_s_;
}
inline void CubeConfig::set_v_lb_s(double value) {
  
  v_lb_s_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.v_lb_s)
}

// double v_lb_l = 2;
inline void CubeConfig::clear_v_lb_l() {
  v_lb_l_ = 0;
}
inline double CubeConfig::v_lb_l() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.v_lb_l)
  return v_lb_l_;
}
inline void CubeConfig::set_v_lb_l(double value) {
  
  v_lb_l_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.v_lb_l)
}

// double v_ub_s = 3;
inline void CubeConfig::clear_v_ub_s() {
  v_ub_s_ = 0;
}
inline double CubeConfig::v_ub_s() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.v_ub_s)
  return v_ub_s_;
}
inline void CubeConfig::set_v_ub_s(double value) {
  
  v_ub_s_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.v_ub_s)
}

// double v_ub_l = 4;
inline void CubeConfig::clear_v_ub_l() {
  v_ub_l_ = 0;
}
inline double CubeConfig::v_ub_l() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.v_ub_l)
  return v_ub_l_;
}
inline void CubeConfig::set_v_ub_l(double value) {
  
  v_ub_l_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.v_ub_l)
}

// double a_lb_s = 5;
inline void CubeConfig::clear_a_lb_s() {
  a_lb_s_ = 0;
}
inline double CubeConfig::a_lb_s() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.a_lb_s)
  return a_lb_s_;
}
inline void CubeConfig::set_a_lb_s(double value) {
  
  a_lb_s_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.a_lb_s)
}

// double a_lb_l = 6;
inline void CubeConfig::clear_a_lb_l() {
  a_lb_l_ = 0;
}
inline double CubeConfig::a_lb_l() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.a_lb_l)
  return a_lb_l_;
}
inline void CubeConfig::set_a_lb_l(double value) {
  
  a_lb_l_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.a_lb_l)
}

// double a_ub_s = 7;
inline void CubeConfig::clear_a_ub_s() {
  a_ub_s_ = 0;
}
inline double CubeConfig::a_ub_s() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.a_ub_s)
  return a_ub_s_;
}
inline void CubeConfig::set_a_ub_s(double value) {
  
  a_ub_s_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.a_ub_s)
}

// double a_ub_l = 8;
inline void CubeConfig::clear_a_ub_l() {
  a_ub_l_ = 0;
}
inline double CubeConfig::a_ub_l() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CubeConfig.a_ub_l)
  return a_ub_l_;
}
inline void CubeConfig::set_a_ub_l(double value) {
  
  a_ub_l_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CubeConfig.a_ub_l)
}

// -------------------------------------------------------------------

// CarConfig

// double car_width = 1;
inline void CarConfig::clear_car_width() {
  car_width_ = 0;
}
inline double CarConfig::car_width() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CarConfig.car_width)
  return car_width_;
}
inline void CarConfig::set_car_width(double value) {
  
  car_width_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CarConfig.car_width)
}

// double car_length = 2;
inline void CarConfig::clear_car_length() {
  car_length_ = 0;
}
inline double CarConfig::car_length() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CarConfig.car_length)
  return car_length_;
}
inline void CarConfig::set_car_length(double value) {
  
  car_length_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CarConfig.car_length)
}

// -------------------------------------------------------------------

// MapConfig

// double reference_speed = 1;
inline void MapConfig::clear_reference_speed() {
  reference_speed_ = 0;
}
inline double MapConfig::reference_speed() const {
  // @@protoc_insertion_point(field_get:planning.umbp.MapConfig.reference_speed)
  return reference_speed_;
}
inline void MapConfig::set_reference_speed(double value) {
  
  reference_speed_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.MapConfig.reference_speed)
}

// -------------------------------------------------------------------

// Config

// string name = 1;
inline void Config::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::name() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.name)
  return name_.GetNoArena();
}
inline void Config::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.name)
}
#if LANG_CXX11
inline void Config::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.name)
}
#endif
inline void Config::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.name)
}
inline void Config::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.name)
}
inline ::std::string* Config::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_name() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.name)
}

// string version = 2;
inline void Config::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::version() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.version)
  return version_.GetNoArena();
}
inline void Config::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.version)
}
#if LANG_CXX11
inline void Config::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.version)
}
#endif
inline void Config::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.version)
}
inline void Config::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.version)
}
inline ::std::string* Config::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_version() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.version)
}

// string status = 3;
inline void Config::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::status() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.status)
  return status_.GetNoArena();
}
inline void Config::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.status)
}
#if LANG_CXX11
inline void Config::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.status)
}
#endif
inline void Config::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.status)
}
inline void Config::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.status)
}
inline ::std::string* Config::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_status() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.status)
}

// .planning.umbp.CostConfig cost = 4;
inline bool Config::has_cost() const {
  return this != internal_default_instance() && cost_ != NULL;
}
inline void Config::clear_cost() {
  if (GetArenaNoVirtual() == NULL && cost_ != NULL) {
    delete cost_;
  }
  cost_ = NULL;
}
inline const ::planning::umbp::CostConfig& Config::_internal_cost() const {
  return *cost_;
}
inline const ::planning::umbp::CostConfig& Config::cost() const {
  const ::planning::umbp::CostConfig* p = cost_;
  // @@protoc_insertion_point(field_get:planning.umbp.Config.cost)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::CostConfig*>(
      &::planning::umbp::_CostConfig_default_instance_);
}
inline ::planning::umbp::CostConfig* Config::release_cost() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.cost)
  
  ::planning::umbp::CostConfig* temp = cost_;
  cost_ = NULL;
  return temp;
}
inline ::planning::umbp::CostConfig* Config::mutable_cost() {
  
  if (cost_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::CostConfig>(GetArenaNoVirtual());
    cost_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.cost)
  return cost_;
}
inline void Config::set_allocated_cost(::planning::umbp::CostConfig* cost) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cost_;
  }
  if (cost) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cost = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cost, submessage_arena);
    }
    
  } else {
    
  }
  cost_ = cost;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.cost)
}

// .planning.umbp.PropogateConfig propogate = 5;
inline bool Config::has_propogate() const {
  return this != internal_default_instance() && propogate_ != NULL;
}
inline void Config::clear_propogate() {
  if (GetArenaNoVirtual() == NULL && propogate_ != NULL) {
    delete propogate_;
  }
  propogate_ = NULL;
}
inline const ::planning::umbp::PropogateConfig& Config::_internal_propogate() const {
  return *propogate_;
}
inline const ::planning::umbp::PropogateConfig& Config::propogate() const {
  const ::planning::umbp::PropogateConfig* p = propogate_;
  // @@protoc_insertion_point(field_get:planning.umbp.Config.propogate)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::PropogateConfig*>(
      &::planning::umbp::_PropogateConfig_default_instance_);
}
inline ::planning::umbp::PropogateConfig* Config::release_propogate() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.propogate)
  
  ::planning::umbp::PropogateConfig* temp = propogate_;
  propogate_ = NULL;
  return temp;
}
inline ::planning::umbp::PropogateConfig* Config::mutable_propogate() {
  
  if (propogate_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::PropogateConfig>(GetArenaNoVirtual());
    propogate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.propogate)
  return propogate_;
}
inline void Config::set_allocated_propogate(::planning::umbp::PropogateConfig* propogate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete propogate_;
  }
  if (propogate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      propogate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, propogate, submessage_arena);
    }
    
  } else {
    
  }
  propogate_ = propogate;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.propogate)
}

// .planning.umbp.EgoConfig ego = 6;
inline bool Config::has_ego() const {
  return this != internal_default_instance() && ego_ != NULL;
}
inline void Config::clear_ego() {
  if (GetArenaNoVirtual() == NULL && ego_ != NULL) {
    delete ego_;
  }
  ego_ = NULL;
}
inline const ::planning::umbp::EgoConfig& Config::_internal_ego() const {
  return *ego_;
}
inline const ::planning::umbp::EgoConfig& Config::ego() const {
  const ::planning::umbp::EgoConfig* p = ego_;
  // @@protoc_insertion_point(field_get:planning.umbp.Config.ego)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::EgoConfig*>(
      &::planning::umbp::_EgoConfig_default_instance_);
}
inline ::planning::umbp::EgoConfig* Config::release_ego() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.ego)
  
  ::planning::umbp::EgoConfig* temp = ego_;
  ego_ = NULL;
  return temp;
}
inline ::planning::umbp::EgoConfig* Config::mutable_ego() {
  
  if (ego_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::EgoConfig>(GetArenaNoVirtual());
    ego_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.ego)
  return ego_;
}
inline void Config::set_allocated_ego(::planning::umbp::EgoConfig* ego) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ego_;
  }
  if (ego) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ego = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ego, submessage_arena);
    }
    
  } else {
    
  }
  ego_ = ego;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.ego)
}

// .planning.umbp.BezierConfig bezier = 7;
inline bool Config::has_bezier() const {
  return this != internal_default_instance() && bezier_ != NULL;
}
inline void Config::clear_bezier() {
  if (GetArenaNoVirtual() == NULL && bezier_ != NULL) {
    delete bezier_;
  }
  bezier_ = NULL;
}
inline const ::planning::umbp::BezierConfig& Config::_internal_bezier() const {
  return *bezier_;
}
inline const ::planning::umbp::BezierConfig& Config::bezier() const {
  const ::planning::umbp::BezierConfig* p = bezier_;
  // @@protoc_insertion_point(field_get:planning.umbp.Config.bezier)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::umbp::BezierConfig*>(
      &::planning::umbp::_BezierConfig_default_instance_);
}
inline ::planning::umbp::BezierConfig* Config::release_bezier() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.bezier)
  
  ::planning::umbp::BezierConfig* temp = bezier_;
  bezier_ = NULL;
  return temp;
}
inline ::planning::umbp::BezierConfig* Config::mutable_bezier() {
  
  if (bezier_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::umbp::BezierConfig>(GetArenaNoVirtual());
    bezier_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.bezier)
  return bezier_;
}
inline void Config::set_allocated_bezier(::planning::umbp::BezierConfig* bezier) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bezier_;
  }
  if (bezier) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bezier = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bezier, submessage_arena);
    }
    
  } else {
    
  }
  bezier_ = bezier;
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.bezier)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace umbp
}  // namespace planning

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_umbp_5fconfig_2eproto
