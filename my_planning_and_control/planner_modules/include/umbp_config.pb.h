// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: umbp_config.proto

#ifndef PROTOBUF_umbp_5fconfig_2eproto__INCLUDED
#define PROTOBUF_umbp_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace planning {
namespace umbp {
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class CostConfig;
class CostConfigDefaultTypeInternal;
extern CostConfigDefaultTypeInternal _CostConfig_default_instance_;
class EfficiencyCost;
class EfficiencyCostDefaultTypeInternal;
extern EfficiencyCostDefaultTypeInternal _EfficiencyCost_default_instance_;
class FpbConfig;
class FpbConfigDefaultTypeInternal;
extern FpbConfigDefaultTypeInternal _FpbConfig_default_instance_;
class NavigationCost;
class NavigationCostDefaultTypeInternal;
extern NavigationCostDefaultTypeInternal _NavigationCost_default_instance_;
class PropogateConfig;
class PropogateConfigDefaultTypeInternal;
extern PropogateConfigDefaultTypeInternal _PropogateConfig_default_instance_;
class SafetyCost;
class SafetyCostDefaultTypeInternal;
extern SafetyCostDefaultTypeInternal _SafetyCost_default_instance_;
class SampleConfig;
class SampleConfigDefaultTypeInternal;
extern SampleConfigDefaultTypeInternal _SampleConfig_default_instance_;
class UserCost;
class UserCostDefaultTypeInternal;
extern UserCostDefaultTypeInternal _UserCost_default_instance_;
}  // namespace umbp
}  // namespace planning

namespace planning {
namespace umbp {

namespace protobuf_umbp_5fconfig_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_umbp_5fconfig_2eproto

// ===================================================================

class EfficiencyCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.EfficiencyCost) */ {
 public:
  EfficiencyCost();
  virtual ~EfficiencyCost();

  EfficiencyCost(const EfficiencyCost& from);

  inline EfficiencyCost& operator=(const EfficiencyCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EfficiencyCost& default_instance();

  static inline const EfficiencyCost* internal_default_instance() {
    return reinterpret_cast<const EfficiencyCost*>(
               &_EfficiencyCost_default_instance_);
  }

  void Swap(EfficiencyCost* other);

  // implements Message ----------------------------------------------

  inline EfficiencyCost* New() const PROTOBUF_FINAL { return New(NULL); }

  EfficiencyCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EfficiencyCost& from);
  void MergeFrom(const EfficiencyCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EfficiencyCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ego_lack_speed_to_desired_unit_cost = 1;
  void clear_ego_lack_speed_to_desired_unit_cost();
  static const int kEgoLackSpeedToDesiredUnitCostFieldNumber = 1;
  double ego_lack_speed_to_desired_unit_cost() const;
  void set_ego_lack_speed_to_desired_unit_cost(double value);

  // double ego_over_speed_to_desired_unit_cost = 2;
  void clear_ego_over_speed_to_desired_unit_cost();
  static const int kEgoOverSpeedToDesiredUnitCostFieldNumber = 2;
  double ego_over_speed_to_desired_unit_cost() const;
  void set_ego_over_speed_to_desired_unit_cost(double value);

  // double ego_desired_speed_tolerate_gap = 3;
  void clear_ego_desired_speed_tolerate_gap();
  static const int kEgoDesiredSpeedTolerateGapFieldNumber = 3;
  double ego_desired_speed_tolerate_gap() const;
  void set_ego_desired_speed_tolerate_gap(double value);

  // double leading_distance_th = 4;
  void clear_leading_distance_th();
  static const int kLeadingDistanceThFieldNumber = 4;
  double leading_distance_th() const;
  void set_leading_distance_th(double value);

  // double min_distance_ratio = 5;
  void clear_min_distance_ratio();
  static const int kMinDistanceRatioFieldNumber = 5;
  double min_distance_ratio() const;
  void set_min_distance_ratio(double value);

  // double ego_speed_blocked_by_leading_unit_cost = 6;
  void clear_ego_speed_blocked_by_leading_unit_cost();
  static const int kEgoSpeedBlockedByLeadingUnitCostFieldNumber = 6;
  double ego_speed_blocked_by_leading_unit_cost() const;
  void set_ego_speed_blocked_by_leading_unit_cost(double value);

  // double leading_speed_blocked_desired_vel_unit_cost = 7;
  void clear_leading_speed_blocked_desired_vel_unit_cost();
  static const int kLeadingSpeedBlockedDesiredVelUnitCostFieldNumber = 7;
  double leading_speed_blocked_desired_vel_unit_cost() const;
  void set_leading_speed_blocked_desired_vel_unit_cost(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.EfficiencyCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ego_lack_speed_to_desired_unit_cost_;
  double ego_over_speed_to_desired_unit_cost_;
  double ego_desired_speed_tolerate_gap_;
  double leading_distance_th_;
  double min_distance_ratio_;
  double ego_speed_blocked_by_leading_unit_cost_;
  double leading_speed_blocked_desired_vel_unit_cost_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SafetyCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.SafetyCost) */ {
 public:
  SafetyCost();
  virtual ~SafetyCost();

  SafetyCost(const SafetyCost& from);

  inline SafetyCost& operator=(const SafetyCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyCost& default_instance();

  static inline const SafetyCost* internal_default_instance() {
    return reinterpret_cast<const SafetyCost*>(
               &_SafetyCost_default_instance_);
  }

  void Swap(SafetyCost* other);

  // implements Message ----------------------------------------------

  inline SafetyCost* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyCost& from);
  void MergeFrom(const SafetyCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ego_to_obs = 1;
  void clear_ego_to_obs();
  static const int kEgoToObsFieldNumber = 1;
  double ego_to_obs() const;
  void set_ego_to_obs(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.SafetyCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ego_to_obs_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.UserCost) */ {
 public:
  UserCost();
  virtual ~UserCost();

  UserCost(const UserCost& from);

  inline UserCost& operator=(const UserCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCost& default_instance();

  static inline const UserCost* internal_default_instance() {
    return reinterpret_cast<const UserCost*>(
               &_UserCost_default_instance_);
  }

  void Swap(UserCost* other);

  // implements Message ----------------------------------------------

  inline UserCost* New() const PROTOBUF_FINAL { return New(NULL); }

  UserCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserCost& from);
  void MergeFrom(const UserCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double late_operate_unit_cost = 1;
  void clear_late_operate_unit_cost();
  static const int kLateOperateUnitCostFieldNumber = 1;
  double late_operate_unit_cost() const;
  void set_late_operate_unit_cost(double value);

  // double cancel_operation_unit_cost = 2;
  void clear_cancel_operation_unit_cost();
  static const int kCancelOperationUnitCostFieldNumber = 2;
  double cancel_operation_unit_cost() const;
  void set_cancel_operation_unit_cost(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.UserCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double late_operate_unit_cost_;
  double cancel_operation_unit_cost_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavigationCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.NavigationCost) */ {
 public:
  NavigationCost();
  virtual ~NavigationCost();

  NavigationCost(const NavigationCost& from);

  inline NavigationCost& operator=(const NavigationCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationCost& default_instance();

  static inline const NavigationCost* internal_default_instance() {
    return reinterpret_cast<const NavigationCost*>(
               &_NavigationCost_default_instance_);
  }

  void Swap(NavigationCost* other);

  // implements Message ----------------------------------------------

  inline NavigationCost* New() const PROTOBUF_FINAL { return New(NULL); }

  NavigationCost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavigationCost& from);
  void MergeFrom(const NavigationCost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavigationCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ref_line_change = 1;
  void clear_ref_line_change();
  static const int kRefLineChangeFieldNumber = 1;
  double ref_line_change() const;
  void set_ref_line_change(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.NavigationCost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ref_line_change_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FpbConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.FpbConfig) */ {
 public:
  FpbConfig();
  virtual ~FpbConfig();

  FpbConfig(const FpbConfig& from);

  inline FpbConfig& operator=(const FpbConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FpbConfig& default_instance();

  static inline const FpbConfig* internal_default_instance() {
    return reinterpret_cast<const FpbConfig*>(
               &_FpbConfig_default_instance_);
  }

  void Swap(FpbConfig* other);

  // implements Message ----------------------------------------------

  inline FpbConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  FpbConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FpbConfig& from);
  void MergeFrom(const FpbConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FpbConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double layer_time = 1;
  void clear_layer_time();
  static const int kLayerTimeFieldNumber = 1;
  double layer_time() const;
  void set_layer_time(double value);

  // double step = 2;
  void clear_step();
  static const int kStepFieldNumber = 2;
  double step() const;
  void set_step(double value);

  // int32 tree_height = 3;
  void clear_tree_height();
  static const int kTreeHeightFieldNumber = 3;
  ::google::protobuf::int32 tree_height() const;
  void set_tree_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning.umbp.FpbConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double layer_time_;
  double step_;
  ::google::protobuf::int32 tree_height_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SampleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.SampleConfig) */ {
 public:
  SampleConfig();
  virtual ~SampleConfig();

  SampleConfig(const SampleConfig& from);

  inline SampleConfig& operator=(const SampleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SampleConfig& default_instance();

  static inline const SampleConfig* internal_default_instance() {
    return reinterpret_cast<const SampleConfig*>(
               &_SampleConfig_default_instance_);
  }

  void Swap(SampleConfig* other);

  // implements Message ----------------------------------------------

  inline SampleConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  SampleConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SampleConfig& from);
  void MergeFrom(const SampleConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SampleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double s_sample_distance = 1;
  void clear_s_sample_distance();
  static const int kSSampleDistanceFieldNumber = 1;
  double s_sample_distance() const;
  void set_s_sample_distance(double value);

  // double l_sample_distance = 3;
  void clear_l_sample_distance();
  static const int kLSampleDistanceFieldNumber = 3;
  double l_sample_distance() const;
  void set_l_sample_distance(double value);

  // int32 s_sample_num = 2;
  void clear_s_sample_num();
  static const int kSSampleNumFieldNumber = 2;
  ::google::protobuf::int32 s_sample_num() const;
  void set_s_sample_num(::google::protobuf::int32 value);

  // int32 l_sample_num = 4;
  void clear_l_sample_num();
  static const int kLSampleNumFieldNumber = 4;
  ::google::protobuf::int32 l_sample_num() const;
  void set_l_sample_num(::google::protobuf::int32 value);

  // double acc_ref = 5;
  void clear_acc_ref();
  static const int kAccRefFieldNumber = 5;
  double acc_ref() const;
  void set_acc_ref(double value);

  // double dec_ref = 6;
  void clear_dec_ref();
  static const int kDecRefFieldNumber = 6;
  double dec_ref() const;
  void set_dec_ref(double value);

  // double lane_width = 7;
  void clear_lane_width();
  static const int kLaneWidthFieldNumber = 7;
  double lane_width() const;
  void set_lane_width(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.SampleConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double s_sample_distance_;
  double l_sample_distance_;
  ::google::protobuf::int32 s_sample_num_;
  ::google::protobuf::int32 l_sample_num_;
  double acc_ref_;
  double dec_ref_;
  double lane_width_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropogateConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.PropogateConfig) */ {
 public:
  PropogateConfig();
  virtual ~PropogateConfig();

  PropogateConfig(const PropogateConfig& from);

  inline PropogateConfig& operator=(const PropogateConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropogateConfig& default_instance();

  static inline const PropogateConfig* internal_default_instance() {
    return reinterpret_cast<const PropogateConfig*>(
               &_PropogateConfig_default_instance_);
  }

  void Swap(PropogateConfig* other);

  // implements Message ----------------------------------------------

  inline PropogateConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PropogateConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PropogateConfig& from);
  void MergeFrom(const PropogateConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PropogateConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.FpbConfig fpb = 1;
  bool has_fpb() const;
  void clear_fpb();
  static const int kFpbFieldNumber = 1;
  const ::planning::umbp::FpbConfig& fpb() const;
  ::planning::umbp::FpbConfig* mutable_fpb();
  ::planning::umbp::FpbConfig* release_fpb();
  void set_allocated_fpb(::planning::umbp::FpbConfig* fpb);

  // .planning.umbp.SampleConfig sample = 2;
  bool has_sample() const;
  void clear_sample();
  static const int kSampleFieldNumber = 2;
  const ::planning::umbp::SampleConfig& sample() const;
  ::planning::umbp::SampleConfig* mutable_sample();
  ::planning::umbp::SampleConfig* release_sample();
  void set_allocated_sample(::planning::umbp::SampleConfig* sample);

  // @@protoc_insertion_point(class_scope:planning.umbp.PropogateConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::FpbConfig* fpb_;
  ::planning::umbp::SampleConfig* sample_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CostConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.CostConfig) */ {
 public:
  CostConfig();
  virtual ~CostConfig();

  CostConfig(const CostConfig& from);

  inline CostConfig& operator=(const CostConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CostConfig& default_instance();

  static inline const CostConfig* internal_default_instance() {
    return reinterpret_cast<const CostConfig*>(
               &_CostConfig_default_instance_);
  }

  void Swap(CostConfig* other);

  // implements Message ----------------------------------------------

  inline CostConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  CostConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CostConfig& from);
  void MergeFrom(const CostConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CostConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.umbp.EfficiencyCost efficiency = 1;
  bool has_efficiency() const;
  void clear_efficiency();
  static const int kEfficiencyFieldNumber = 1;
  const ::planning::umbp::EfficiencyCost& efficiency() const;
  ::planning::umbp::EfficiencyCost* mutable_efficiency();
  ::planning::umbp::EfficiencyCost* release_efficiency();
  void set_allocated_efficiency(::planning::umbp::EfficiencyCost* efficiency);

  // .planning.umbp.SafetyCost safety = 2;
  bool has_safety() const;
  void clear_safety();
  static const int kSafetyFieldNumber = 2;
  const ::planning::umbp::SafetyCost& safety() const;
  ::planning::umbp::SafetyCost* mutable_safety();
  ::planning::umbp::SafetyCost* release_safety();
  void set_allocated_safety(::planning::umbp::SafetyCost* safety);

  // .planning.umbp.UserCost user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  const ::planning::umbp::UserCost& user() const;
  ::planning::umbp::UserCost* mutable_user();
  ::planning::umbp::UserCost* release_user();
  void set_allocated_user(::planning::umbp::UserCost* user);

  // .planning.umbp.NavigationCost navigation = 4;
  bool has_navigation() const;
  void clear_navigation();
  static const int kNavigationFieldNumber = 4;
  const ::planning::umbp::NavigationCost& navigation() const;
  ::planning::umbp::NavigationCost* mutable_navigation();
  ::planning::umbp::NavigationCost* release_navigation();
  void set_allocated_navigation(::planning::umbp::NavigationCost* navigation);

  // double discount_factor = 5;
  void clear_discount_factor();
  static const int kDiscountFactorFieldNumber = 5;
  double discount_factor() const;
  void set_discount_factor(double value);

  // @@protoc_insertion_point(class_scope:planning.umbp.CostConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::umbp::EfficiencyCost* efficiency_;
  ::planning::umbp::SafetyCost* safety_;
  ::planning::umbp::UserCost* user_;
  ::planning::umbp::NavigationCost* navigation_;
  double discount_factor_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.umbp.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  inline Config* New() const PROTOBUF_FINAL { return New(NULL); }

  Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // .planning.umbp.CostConfig cost = 4;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  const ::planning::umbp::CostConfig& cost() const;
  ::planning::umbp::CostConfig* mutable_cost();
  ::planning::umbp::CostConfig* release_cost();
  void set_allocated_cost(::planning::umbp::CostConfig* cost);

  // .planning.umbp.PropogateConfig propogate = 5;
  bool has_propogate() const;
  void clear_propogate();
  static const int kPropogateFieldNumber = 5;
  const ::planning::umbp::PropogateConfig& propogate() const;
  ::planning::umbp::PropogateConfig* mutable_propogate();
  ::planning::umbp::PropogateConfig* release_propogate();
  void set_allocated_propogate(::planning::umbp::PropogateConfig* propogate);

  // @@protoc_insertion_point(class_scope:planning.umbp.Config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::planning::umbp::CostConfig* cost_;
  ::planning::umbp::PropogateConfig* propogate_;
  mutable int _cached_size_;
  friend struct  protobuf_umbp_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EfficiencyCost

// double ego_lack_speed_to_desired_unit_cost = 1;
inline void EfficiencyCost::clear_ego_lack_speed_to_desired_unit_cost() {
  ego_lack_speed_to_desired_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_lack_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_lack_speed_to_desired_unit_cost)
  return ego_lack_speed_to_desired_unit_cost_;
}
inline void EfficiencyCost::set_ego_lack_speed_to_desired_unit_cost(double value) {
  
  ego_lack_speed_to_desired_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_lack_speed_to_desired_unit_cost)
}

// double ego_over_speed_to_desired_unit_cost = 2;
inline void EfficiencyCost::clear_ego_over_speed_to_desired_unit_cost() {
  ego_over_speed_to_desired_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_over_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_over_speed_to_desired_unit_cost)
  return ego_over_speed_to_desired_unit_cost_;
}
inline void EfficiencyCost::set_ego_over_speed_to_desired_unit_cost(double value) {
  
  ego_over_speed_to_desired_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_over_speed_to_desired_unit_cost)
}

// double ego_desired_speed_tolerate_gap = 3;
inline void EfficiencyCost::clear_ego_desired_speed_tolerate_gap() {
  ego_desired_speed_tolerate_gap_ = 0;
}
inline double EfficiencyCost::ego_desired_speed_tolerate_gap() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_desired_speed_tolerate_gap)
  return ego_desired_speed_tolerate_gap_;
}
inline void EfficiencyCost::set_ego_desired_speed_tolerate_gap(double value) {
  
  ego_desired_speed_tolerate_gap_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_desired_speed_tolerate_gap)
}

// double leading_distance_th = 4;
inline void EfficiencyCost::clear_leading_distance_th() {
  leading_distance_th_ = 0;
}
inline double EfficiencyCost::leading_distance_th() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.leading_distance_th)
  return leading_distance_th_;
}
inline void EfficiencyCost::set_leading_distance_th(double value) {
  
  leading_distance_th_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.leading_distance_th)
}

// double min_distance_ratio = 5;
inline void EfficiencyCost::clear_min_distance_ratio() {
  min_distance_ratio_ = 0;
}
inline double EfficiencyCost::min_distance_ratio() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.min_distance_ratio)
  return min_distance_ratio_;
}
inline void EfficiencyCost::set_min_distance_ratio(double value) {
  
  min_distance_ratio_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.min_distance_ratio)
}

// double ego_speed_blocked_by_leading_unit_cost = 6;
inline void EfficiencyCost::clear_ego_speed_blocked_by_leading_unit_cost() {
  ego_speed_blocked_by_leading_unit_cost_ = 0;
}
inline double EfficiencyCost::ego_speed_blocked_by_leading_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.ego_speed_blocked_by_leading_unit_cost)
  return ego_speed_blocked_by_leading_unit_cost_;
}
inline void EfficiencyCost::set_ego_speed_blocked_by_leading_unit_cost(double value) {
  
  ego_speed_blocked_by_leading_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.ego_speed_blocked_by_leading_unit_cost)
}

// double leading_speed_blocked_desired_vel_unit_cost = 7;
inline void EfficiencyCost::clear_leading_speed_blocked_desired_vel_unit_cost() {
  leading_speed_blocked_desired_vel_unit_cost_ = 0;
}
inline double EfficiencyCost::leading_speed_blocked_desired_vel_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.EfficiencyCost.leading_speed_blocked_desired_vel_unit_cost)
  return leading_speed_blocked_desired_vel_unit_cost_;
}
inline void EfficiencyCost::set_leading_speed_blocked_desired_vel_unit_cost(double value) {
  
  leading_speed_blocked_desired_vel_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.EfficiencyCost.leading_speed_blocked_desired_vel_unit_cost)
}

// -------------------------------------------------------------------

// SafetyCost

// double ego_to_obs = 1;
inline void SafetyCost::clear_ego_to_obs() {
  ego_to_obs_ = 0;
}
inline double SafetyCost::ego_to_obs() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SafetyCost.ego_to_obs)
  return ego_to_obs_;
}
inline void SafetyCost::set_ego_to_obs(double value) {
  
  ego_to_obs_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SafetyCost.ego_to_obs)
}

// -------------------------------------------------------------------

// UserCost

// double late_operate_unit_cost = 1;
inline void UserCost::clear_late_operate_unit_cost() {
  late_operate_unit_cost_ = 0;
}
inline double UserCost::late_operate_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.UserCost.late_operate_unit_cost)
  return late_operate_unit_cost_;
}
inline void UserCost::set_late_operate_unit_cost(double value) {
  
  late_operate_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.UserCost.late_operate_unit_cost)
}

// double cancel_operation_unit_cost = 2;
inline void UserCost::clear_cancel_operation_unit_cost() {
  cancel_operation_unit_cost_ = 0;
}
inline double UserCost::cancel_operation_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.UserCost.cancel_operation_unit_cost)
  return cancel_operation_unit_cost_;
}
inline void UserCost::set_cancel_operation_unit_cost(double value) {
  
  cancel_operation_unit_cost_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.UserCost.cancel_operation_unit_cost)
}

// -------------------------------------------------------------------

// NavigationCost

// double ref_line_change = 1;
inline void NavigationCost::clear_ref_line_change() {
  ref_line_change_ = 0;
}
inline double NavigationCost::ref_line_change() const {
  // @@protoc_insertion_point(field_get:planning.umbp.NavigationCost.ref_line_change)
  return ref_line_change_;
}
inline void NavigationCost::set_ref_line_change(double value) {
  
  ref_line_change_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.NavigationCost.ref_line_change)
}

// -------------------------------------------------------------------

// FpbConfig

// double layer_time = 1;
inline void FpbConfig::clear_layer_time() {
  layer_time_ = 0;
}
inline double FpbConfig::layer_time() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.layer_time)
  return layer_time_;
}
inline void FpbConfig::set_layer_time(double value) {
  
  layer_time_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.layer_time)
}

// double step = 2;
inline void FpbConfig::clear_step() {
  step_ = 0;
}
inline double FpbConfig::step() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.step)
  return step_;
}
inline void FpbConfig::set_step(double value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.step)
}

// int32 tree_height = 3;
inline void FpbConfig::clear_tree_height() {
  tree_height_ = 0;
}
inline ::google::protobuf::int32 FpbConfig::tree_height() const {
  // @@protoc_insertion_point(field_get:planning.umbp.FpbConfig.tree_height)
  return tree_height_;
}
inline void FpbConfig::set_tree_height(::google::protobuf::int32 value) {
  
  tree_height_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.FpbConfig.tree_height)
}

// -------------------------------------------------------------------

// SampleConfig

// double s_sample_distance = 1;
inline void SampleConfig::clear_s_sample_distance() {
  s_sample_distance_ = 0;
}
inline double SampleConfig::s_sample_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.s_sample_distance)
  return s_sample_distance_;
}
inline void SampleConfig::set_s_sample_distance(double value) {
  
  s_sample_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.s_sample_distance)
}

// int32 s_sample_num = 2;
inline void SampleConfig::clear_s_sample_num() {
  s_sample_num_ = 0;
}
inline ::google::protobuf::int32 SampleConfig::s_sample_num() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.s_sample_num)
  return s_sample_num_;
}
inline void SampleConfig::set_s_sample_num(::google::protobuf::int32 value) {
  
  s_sample_num_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.s_sample_num)
}

// double l_sample_distance = 3;
inline void SampleConfig::clear_l_sample_distance() {
  l_sample_distance_ = 0;
}
inline double SampleConfig::l_sample_distance() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.l_sample_distance)
  return l_sample_distance_;
}
inline void SampleConfig::set_l_sample_distance(double value) {
  
  l_sample_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.l_sample_distance)
}

// int32 l_sample_num = 4;
inline void SampleConfig::clear_l_sample_num() {
  l_sample_num_ = 0;
}
inline ::google::protobuf::int32 SampleConfig::l_sample_num() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.l_sample_num)
  return l_sample_num_;
}
inline void SampleConfig::set_l_sample_num(::google::protobuf::int32 value) {
  
  l_sample_num_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.l_sample_num)
}

// double acc_ref = 5;
inline void SampleConfig::clear_acc_ref() {
  acc_ref_ = 0;
}
inline double SampleConfig::acc_ref() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.acc_ref)
  return acc_ref_;
}
inline void SampleConfig::set_acc_ref(double value) {
  
  acc_ref_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.acc_ref)
}

// double dec_ref = 6;
inline void SampleConfig::clear_dec_ref() {
  dec_ref_ = 0;
}
inline double SampleConfig::dec_ref() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.dec_ref)
  return dec_ref_;
}
inline void SampleConfig::set_dec_ref(double value) {
  
  dec_ref_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.dec_ref)
}

// double lane_width = 7;
inline void SampleConfig::clear_lane_width() {
  lane_width_ = 0;
}
inline double SampleConfig::lane_width() const {
  // @@protoc_insertion_point(field_get:planning.umbp.SampleConfig.lane_width)
  return lane_width_;
}
inline void SampleConfig::set_lane_width(double value) {
  
  lane_width_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.SampleConfig.lane_width)
}

// -------------------------------------------------------------------

// PropogateConfig

// .planning.umbp.FpbConfig fpb = 1;
inline bool PropogateConfig::has_fpb() const {
  return this != internal_default_instance() && fpb_ != NULL;
}
inline void PropogateConfig::clear_fpb() {
  if (GetArenaNoVirtual() == NULL && fpb_ != NULL) delete fpb_;
  fpb_ = NULL;
}
inline const ::planning::umbp::FpbConfig& PropogateConfig::fpb() const {
  // @@protoc_insertion_point(field_get:planning.umbp.PropogateConfig.fpb)
  return fpb_ != NULL ? *fpb_
                         : *::planning::umbp::FpbConfig::internal_default_instance();
}
inline ::planning::umbp::FpbConfig* PropogateConfig::mutable_fpb() {
  
  if (fpb_ == NULL) {
    fpb_ = new ::planning::umbp::FpbConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.PropogateConfig.fpb)
  return fpb_;
}
inline ::planning::umbp::FpbConfig* PropogateConfig::release_fpb() {
  // @@protoc_insertion_point(field_release:planning.umbp.PropogateConfig.fpb)
  
  ::planning::umbp::FpbConfig* temp = fpb_;
  fpb_ = NULL;
  return temp;
}
inline void PropogateConfig::set_allocated_fpb(::planning::umbp::FpbConfig* fpb) {
  delete fpb_;
  fpb_ = fpb;
  if (fpb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.PropogateConfig.fpb)
}

// .planning.umbp.SampleConfig sample = 2;
inline bool PropogateConfig::has_sample() const {
  return this != internal_default_instance() && sample_ != NULL;
}
inline void PropogateConfig::clear_sample() {
  if (GetArenaNoVirtual() == NULL && sample_ != NULL) delete sample_;
  sample_ = NULL;
}
inline const ::planning::umbp::SampleConfig& PropogateConfig::sample() const {
  // @@protoc_insertion_point(field_get:planning.umbp.PropogateConfig.sample)
  return sample_ != NULL ? *sample_
                         : *::planning::umbp::SampleConfig::internal_default_instance();
}
inline ::planning::umbp::SampleConfig* PropogateConfig::mutable_sample() {
  
  if (sample_ == NULL) {
    sample_ = new ::planning::umbp::SampleConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.PropogateConfig.sample)
  return sample_;
}
inline ::planning::umbp::SampleConfig* PropogateConfig::release_sample() {
  // @@protoc_insertion_point(field_release:planning.umbp.PropogateConfig.sample)
  
  ::planning::umbp::SampleConfig* temp = sample_;
  sample_ = NULL;
  return temp;
}
inline void PropogateConfig::set_allocated_sample(::planning::umbp::SampleConfig* sample) {
  delete sample_;
  sample_ = sample;
  if (sample) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.PropogateConfig.sample)
}

// -------------------------------------------------------------------

// CostConfig

// .planning.umbp.EfficiencyCost efficiency = 1;
inline bool CostConfig::has_efficiency() const {
  return this != internal_default_instance() && efficiency_ != NULL;
}
inline void CostConfig::clear_efficiency() {
  if (GetArenaNoVirtual() == NULL && efficiency_ != NULL) delete efficiency_;
  efficiency_ = NULL;
}
inline const ::planning::umbp::EfficiencyCost& CostConfig::efficiency() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.efficiency)
  return efficiency_ != NULL ? *efficiency_
                         : *::planning::umbp::EfficiencyCost::internal_default_instance();
}
inline ::planning::umbp::EfficiencyCost* CostConfig::mutable_efficiency() {
  
  if (efficiency_ == NULL) {
    efficiency_ = new ::planning::umbp::EfficiencyCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.efficiency)
  return efficiency_;
}
inline ::planning::umbp::EfficiencyCost* CostConfig::release_efficiency() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.efficiency)
  
  ::planning::umbp::EfficiencyCost* temp = efficiency_;
  efficiency_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_efficiency(::planning::umbp::EfficiencyCost* efficiency) {
  delete efficiency_;
  efficiency_ = efficiency;
  if (efficiency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.efficiency)
}

// .planning.umbp.SafetyCost safety = 2;
inline bool CostConfig::has_safety() const {
  return this != internal_default_instance() && safety_ != NULL;
}
inline void CostConfig::clear_safety() {
  if (GetArenaNoVirtual() == NULL && safety_ != NULL) delete safety_;
  safety_ = NULL;
}
inline const ::planning::umbp::SafetyCost& CostConfig::safety() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.safety)
  return safety_ != NULL ? *safety_
                         : *::planning::umbp::SafetyCost::internal_default_instance();
}
inline ::planning::umbp::SafetyCost* CostConfig::mutable_safety() {
  
  if (safety_ == NULL) {
    safety_ = new ::planning::umbp::SafetyCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.safety)
  return safety_;
}
inline ::planning::umbp::SafetyCost* CostConfig::release_safety() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.safety)
  
  ::planning::umbp::SafetyCost* temp = safety_;
  safety_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_safety(::planning::umbp::SafetyCost* safety) {
  delete safety_;
  safety_ = safety;
  if (safety) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.safety)
}

// .planning.umbp.UserCost user = 3;
inline bool CostConfig::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void CostConfig::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
inline const ::planning::umbp::UserCost& CostConfig::user() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.user)
  return user_ != NULL ? *user_
                         : *::planning::umbp::UserCost::internal_default_instance();
}
inline ::planning::umbp::UserCost* CostConfig::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::planning::umbp::UserCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.user)
  return user_;
}
inline ::planning::umbp::UserCost* CostConfig::release_user() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.user)
  
  ::planning::umbp::UserCost* temp = user_;
  user_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_user(::planning::umbp::UserCost* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.user)
}

// .planning.umbp.NavigationCost navigation = 4;
inline bool CostConfig::has_navigation() const {
  return this != internal_default_instance() && navigation_ != NULL;
}
inline void CostConfig::clear_navigation() {
  if (GetArenaNoVirtual() == NULL && navigation_ != NULL) delete navigation_;
  navigation_ = NULL;
}
inline const ::planning::umbp::NavigationCost& CostConfig::navigation() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.navigation)
  return navigation_ != NULL ? *navigation_
                         : *::planning::umbp::NavigationCost::internal_default_instance();
}
inline ::planning::umbp::NavigationCost* CostConfig::mutable_navigation() {
  
  if (navigation_ == NULL) {
    navigation_ = new ::planning::umbp::NavigationCost;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.CostConfig.navigation)
  return navigation_;
}
inline ::planning::umbp::NavigationCost* CostConfig::release_navigation() {
  // @@protoc_insertion_point(field_release:planning.umbp.CostConfig.navigation)
  
  ::planning::umbp::NavigationCost* temp = navigation_;
  navigation_ = NULL;
  return temp;
}
inline void CostConfig::set_allocated_navigation(::planning::umbp::NavigationCost* navigation) {
  delete navigation_;
  navigation_ = navigation;
  if (navigation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.CostConfig.navigation)
}

// double discount_factor = 5;
inline void CostConfig::clear_discount_factor() {
  discount_factor_ = 0;
}
inline double CostConfig::discount_factor() const {
  // @@protoc_insertion_point(field_get:planning.umbp.CostConfig.discount_factor)
  return discount_factor_;
}
inline void CostConfig::set_discount_factor(double value) {
  
  discount_factor_ = value;
  // @@protoc_insertion_point(field_set:planning.umbp.CostConfig.discount_factor)
}

// -------------------------------------------------------------------

// Config

// string name = 1;
inline void Config::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::name() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.name)
  return name_.GetNoArena();
}
inline void Config::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.name)
}
#if LANG_CXX11
inline void Config::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.name)
}
#endif
inline void Config::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.name)
}
inline void Config::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.name)
}
inline ::std::string* Config::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_name() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.name)
}

// string version = 2;
inline void Config::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::version() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.version)
  return version_.GetNoArena();
}
inline void Config::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.version)
}
#if LANG_CXX11
inline void Config::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.version)
}
#endif
inline void Config::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.version)
}
inline void Config::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.version)
}
inline ::std::string* Config::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_version() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.version)
}

// string status = 3;
inline void Config::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Config::status() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.status)
  return status_.GetNoArena();
}
inline void Config::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning.umbp.Config.status)
}
#if LANG_CXX11
inline void Config::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning.umbp.Config.status)
}
#endif
inline void Config::set_status(const char* value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning.umbp.Config.status)
}
inline void Config::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning.umbp.Config.status)
}
inline ::std::string* Config::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_status() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.status)
}

// .planning.umbp.CostConfig cost = 4;
inline bool Config::has_cost() const {
  return this != internal_default_instance() && cost_ != NULL;
}
inline void Config::clear_cost() {
  if (GetArenaNoVirtual() == NULL && cost_ != NULL) delete cost_;
  cost_ = NULL;
}
inline const ::planning::umbp::CostConfig& Config::cost() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.cost)
  return cost_ != NULL ? *cost_
                         : *::planning::umbp::CostConfig::internal_default_instance();
}
inline ::planning::umbp::CostConfig* Config::mutable_cost() {
  
  if (cost_ == NULL) {
    cost_ = new ::planning::umbp::CostConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.cost)
  return cost_;
}
inline ::planning::umbp::CostConfig* Config::release_cost() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.cost)
  
  ::planning::umbp::CostConfig* temp = cost_;
  cost_ = NULL;
  return temp;
}
inline void Config::set_allocated_cost(::planning::umbp::CostConfig* cost) {
  delete cost_;
  cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.cost)
}

// .planning.umbp.PropogateConfig propogate = 5;
inline bool Config::has_propogate() const {
  return this != internal_default_instance() && propogate_ != NULL;
}
inline void Config::clear_propogate() {
  if (GetArenaNoVirtual() == NULL && propogate_ != NULL) delete propogate_;
  propogate_ = NULL;
}
inline const ::planning::umbp::PropogateConfig& Config::propogate() const {
  // @@protoc_insertion_point(field_get:planning.umbp.Config.propogate)
  return propogate_ != NULL ? *propogate_
                         : *::planning::umbp::PropogateConfig::internal_default_instance();
}
inline ::planning::umbp::PropogateConfig* Config::mutable_propogate() {
  
  if (propogate_ == NULL) {
    propogate_ = new ::planning::umbp::PropogateConfig;
  }
  // @@protoc_insertion_point(field_mutable:planning.umbp.Config.propogate)
  return propogate_;
}
inline ::planning::umbp::PropogateConfig* Config::release_propogate() {
  // @@protoc_insertion_point(field_release:planning.umbp.Config.propogate)
  
  ::planning::umbp::PropogateConfig* temp = propogate_;
  propogate_ = NULL;
  return temp;
}
inline void Config::set_allocated_propogate(::planning::umbp::PropogateConfig* propogate) {
  delete propogate_;
  propogate_ = propogate;
  if (propogate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:planning.umbp.Config.propogate)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace umbp
}  // namespace planning

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_umbp_5fconfig_2eproto__INCLUDED
